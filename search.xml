<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Dubbo LoadBalance 负载均衡</title>
      <link href="/2023/03/05/Dubbo-LoadBalance-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2023/03/05/Dubbo-LoadBalance-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、负载均衡策略概述"><a href="#一、负载均衡策略概述" class="headerlink" title="一、负载均衡策略概述"></a>一、负载均衡策略概述</h2><p> 大部分使用Dubbo的互联网应用中，服务提供方基本都是以集群的形式提供接口，为了避免大量请求一直集中在一个或者几个服务提供机器上，从而使这些机器负载升高最后影响服务健康状态，需要做一定的负载均衡策略。Dubbo提供了多种负载均衡策略，默认为<strong><em>random</em></strong>，也就是每次随机选择一台服务提供者的服务。</p><p> Dubbo提供的负载均衡策略有如下几种：</p><ul><li>RandomLoadBalance    随机策略</li><li>RoundRobinLoadBalance 轮询策略</li><li>LeastActiveLoadBalance 最少活跃调用数</li><li>ConsistentHashLoadBalance 一致性hash策略</li></ul><h2 id="二、RandomLoadBalance"><a href="#二、RandomLoadBalance" class="headerlink" title="二、RandomLoadBalance"></a>二、RandomLoadBalance</h2><p>  随机策略按照概率设置权重，比较均匀而且可以动态调节提供者的权重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> length = invokers.size(); <span class="comment">// 获取个数</span></span><br><span class="line">      <span class="keyword">int</span> totalWeight = <span class="number">0</span>; <span class="comment">// The sum of weights</span></span><br><span class="line">      <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>; <span class="comment">// Every invoker has the same weight?</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">          <span class="comment">//计算权重</span></span><br><span class="line">          <span class="keyword">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class="line">          totalWeight += weight; <span class="comment">// Sum</span></span><br><span class="line">          <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span> <span class="comment">// 与下一个的invoker的权重不相等</span></span><br><span class="line">                  &amp;&amp; weight != getWeight(invokers.get(i - <span class="number">1</span>), invocation)) &#123;</span><br><span class="line">              sameWeight = <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当拥有不同权重的invoker的时候</span></span><br><span class="line">      <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">          <span class="comment">// If (not every invoker has the same weight &amp; at least one invoker's weight&gt;0), </span></span><br><span class="line">        <span class="comment">// select randomly based on totalWeight.</span></span><br><span class="line">          <span class="keyword">int</span> offset = random.nextInt(totalWeight);<span class="comment">// 在所有权重中选择一个 数</span></span><br><span class="line">          <span class="comment">// Return a invoker based on the random value.</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">//使用 随机出来的这个 offset - invoker的权重值</span></span><br><span class="line">              offset -= getWeight(invokers.get(i), invocation);</span><br><span class="line">              <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 小于0 的时候就返回当前这个invoker</span></span><br><span class="line">                  <span class="keyword">return</span> invokers.get(i);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// If all invokers have the same weight value or totalWeight=0, return evenly.</span></span><br><span class="line">      <span class="comment">// 在集合下标中随机选择一个下标</span></span><br><span class="line">      <span class="keyword">return</span> invokers.get(random.nextInt(length));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>length</code> 获取所有invoker个数， 通过invoker个数循环计算<code>totalWeight</code> 总权重，获取一个<strong>[0,totalWeight)</strong>区间内的随机数，再进行一个减法获取对应的invoker。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 通过参数weight指定权重</span></span><br><span class="line">       <span class="keyword">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), <span class="string">"weight"</span>, <span class="number">100</span>);</span><br><span class="line">       <span class="keyword">if</span> (weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">long</span> timestamp = invoker.getUrl().getParameter(<span class="string">"remote.timestamp"</span>, <span class="number">0L</span>);</span><br><span class="line">           <span class="keyword">if</span> (timestamp &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> uptime = (<span class="keyword">int</span>)(System.currentTimeMillis() - timestamp);</span><br><span class="line">             <span class="comment">// 设置预热时间</span></span><br><span class="line">               <span class="keyword">int</span> warmup = invoker.getUrl().getParameter(<span class="string">"warmup"</span>, <span class="number">600000</span>);</span><br><span class="line">               <span class="keyword">if</span> (uptime &gt; <span class="number">0</span> &amp;&amp; uptime &lt; warmup) &#123;</span><br><span class="line">                   weight = calculateWarmupWeight(uptime, warmup, weight);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> weight;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过getWeight方法可以看到，默认权重为100，可以自定义指定权重和预热时间。</p><h2 id="三、RoundRobinLoadBalance"><a href="#三、RoundRobinLoadBalance" class="headerlink" title="三、RoundRobinLoadBalance"></a>三、RoundRobinLoadBalance</h2><p>轮询，按照公约之后的权重设置轮询比率。存在执行比较慢的服务提供者堆积请求的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 缓存   key =接口全类名.方法名      value = map&lt;每个invoker的标识，WeightedRoundRobin &gt;</span></span><br><span class="line">  <span class="keyword">private</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt; methodWeightMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AtomicBoolean updateLock = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RECYCLE_PERIOD = <span class="number">60000</span>; <span class="comment">// 更新周期</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/// 组装key = 接口全类名.方法名</span></span><br><span class="line">      String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">"."</span> + invocation.getMethodName();</span><br><span class="line">      <span class="comment">// 根据key 从缓存中获取</span></span><br><span class="line">      ConcurrentMap&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.get(key);</span><br><span class="line">      <span class="comment">// 处理是空的情况，如果为空就创建 然后塞进去</span></span><br><span class="line">      <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">          methodWeightMap.putIfAbsent(key, <span class="keyword">new</span> ConcurrentHashMap&lt;String, WeightedRoundRobin&gt;());</span><br><span class="line">          map = methodWeightMap.get(key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//初始化max 为long最小值</span></span><br><span class="line">      <span class="keyword">long</span> maxCurrent = Long.MIN_VALUE;</span><br><span class="line">      <span class="comment">// 获取系统当前时间</span></span><br><span class="line">      <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">      Invoker&lt;T&gt; selectedInvoker = <span class="keyword">null</span>;</span><br><span class="line">      WeightedRoundRobin selectedWRR = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历invokers</span></span><br><span class="line">      <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 将url 转成 身份标识</span></span><br><span class="line">          String identifyString = invoker.getUrl().toIdentityString();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 从map中获取</span></span><br><span class="line">          WeightedRoundRobin weightedRoundRobin = map.get(identifyString);</span><br><span class="line">          <span class="comment">// 计算权重</span></span><br><span class="line">          <span class="keyword">int</span> weight = getWeight(invoker, invocation);</span><br><span class="line">          <span class="keyword">if</span> (weight &lt; <span class="number">0</span>) &#123;<span class="comment">// 如果计算的权重小于0 ， 设置成0</span></span><br><span class="line">              weight = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (weightedRoundRobin == <span class="keyword">null</span>) &#123;<span class="comment">// 没有获取到，说明没有缓存</span></span><br><span class="line">              weightedRoundRobin = <span class="keyword">new</span> WeightedRoundRobin();<span class="comment">//创建WeightedRoundRobin对象</span></span><br><span class="line">              weightedRoundRobin.setWeight(weight);<span class="comment">// 设置权重</span></span><br><span class="line">              <span class="comment">// 将WeightedRoundRobin 对象塞到 map中</span></span><br><span class="line">              map.putIfAbsent(identifyString, weightedRoundRobin);</span><br><span class="line">              weightedRoundRobin = map.get(identifyString);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//如果当前计算的权重与之前缓存的比匹配就设置成当前权重</span></span><br><span class="line">          <span class="keyword">if</span> (weight != weightedRoundRobin.getWeight()) &#123;</span><br><span class="line">              <span class="comment">//weight changed</span></span><br><span class="line">              weightedRoundRobin.setWeight(weight);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 将权重值设置到atomiclong 中 current += weight</span></span><br><span class="line">          <span class="keyword">long</span> cur = weightedRoundRobin.increaseCurrent();</span><br><span class="line">          <span class="comment">// 设置最后修改时间</span></span><br><span class="line">          weightedRoundRobin.setLastUpdate(now);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果当前权重 &gt; max</span></span><br><span class="line">          <span class="keyword">if</span> (cur &gt; maxCurrent) &#123;</span><br><span class="line">              maxCurrent = cur;<span class="comment">// max 设置成赋值为当前权重</span></span><br><span class="line">              selectedInvoker = invoker;</span><br><span class="line">              selectedWRR = weightedRoundRobin;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 总权重+ 当前权重</span></span><br><span class="line">          totalWeight += weight;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据RECYCLE_PERIOD时间 更新map 一般发生在服务提供者数量变更</span></span><br><span class="line">      <span class="comment">// 没有在修改的 &amp;&amp; 当前所有的invoker 列表大小 不等于 缓存里面的大小</span></span><br><span class="line">      <span class="keyword">if</span> (!updateLock.get() &amp;&amp; invokers.size() != map.size()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (updateLock.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;<span class="comment">// cas 操作</span></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// copy -&gt; modify -&gt; update reference</span></span><br><span class="line">                  ConcurrentMap&lt;String, WeightedRoundRobin&gt; newMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, WeightedRoundRobin&gt;();</span><br><span class="line">                  newMap.putAll(map);<span class="comment">// 将map添加到 newMap中</span></span><br><span class="line">                  Iterator&lt;Entry&lt;String, WeightedRoundRobin&gt;&gt; it = newMap.entrySet().iterator();</span><br><span class="line">                  <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                      Entry&lt;String, WeightedRoundRobin&gt; item = it.next();</span><br><span class="line">                      <span class="comment">// 移除 1分钟没有改动过的</span></span><br><span class="line">                      <span class="keyword">if</span> (now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD) &#123;</span><br><span class="line">                          it.remove();</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;<span class="comment">// 替换成新的</span></span><br><span class="line">                  methodWeightMap.put(key, newMap);</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  updateLock.set(<span class="keyword">false</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (selectedInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 将选中的那个weightedRoundRobin 里面的权重（current）设置为当前值减去总权重</span></span><br><span class="line">          selectedWRR.sel(totalWeight); <span class="comment">// current -= totalWeight </span></span><br><span class="line">          <span class="keyword">return</span> selectedInvoker;<span class="comment">// 返回选中的那个invoker</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/// 最后就是选择第一个</span></span><br><span class="line">      <span class="comment">// should not happen here</span></span><br><span class="line">      <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​    轮询算法通过不断更新<code>weightedRoundRobin</code> 对象中的<code>current</code>字段来调整接下来调用要选取的invoker，假如我们将所有invoker的权重设置为相同的值，那么loadbalance将会按照顺序的方式进行调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (selectedInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将选中的那个weightedRoundRobin 里面的权重（current）设置为当前值减去总权重</span></span><br><span class="line">    selectedWRR.sel(totalWeight); <span class="comment">// current -= totalWeight </span></span><br><span class="line">    <span class="keyword">return</span> selectedInvoker;<span class="comment">// 返回选中的那个invoker</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>currentWeight的更新是实现轮询的关键处理逻辑。</p><h2 id="四、LeastActiveLoadBalance"><a href="#四、LeastActiveLoadBalance" class="headerlink" title="四、LeastActiveLoadBalance"></a>四、LeastActiveLoadBalance</h2><p>​    最少活跃调用策略，在了解最小活跃调用负载均衡策略之前需要了解负载均衡中获取invoker活跃数的方法。即通过<code>ActiveLimitFilter</code>获取的invoker的活跃情况。</p><h3 id="com-alibaba-dubbo-rpc-RpcStatus"><a href="#com-alibaba-dubbo-rpc-RpcStatus" class="headerlink" title="com.alibaba.dubbo.rpc.RpcStatus"></a>com.alibaba.dubbo.rpc.RpcStatus</h3><p>这里不做详细分析，需要注意的是在<code>RpcStatus</code>中维护了一个原子类型的<code>active</code>字段，用来表示invoker的并发情况。</p><p>在invoker被调用的前后对字段<code>active</code>进行操作，即：</p><p>invoker调用开始，通过<code>com.alibaba.dubbo.rpc.RpcStatus#beginCount</code>使active + 1</p><p>invoker调用结束，通过<code>com.alibaba.dubbo.rpc.RpcStatus#endCount</code>使active - 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Number of invokers</span></span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">        <span class="comment">// 最活跃初始值是-1</span></span><br><span class="line">        <span class="keyword">int</span> leastActive = -<span class="number">1</span>; </span><br><span class="line">        <span class="comment">//具有相同的最小活动值的调用程序的数量(leastActive)</span></span><br><span class="line">        <span class="keyword">int</span> leastCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] leastIndexs = <span class="keyword">new</span> <span class="keyword">int</span>[length]; </span><br><span class="line">        <span class="comment">// 权重和</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始值</span></span><br><span class="line">        <span class="keyword">int</span> firstWeight = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class="line">            <span class="comment">// 获取当前这个invoker并发数</span></span><br><span class="line">            <span class="keyword">int</span> active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); </span><br><span class="line">            <span class="comment">// 获取权重</span></span><br><span class="line">            <span class="keyword">int</span> afterWarmup = getWeight(invoker, invocation); <span class="comment">// Weight</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一个元素的后或者 当前invoker并发数 小于 最小并发数（初始值是-1）</span></span><br><span class="line">            <span class="keyword">if</span> (leastActive == -<span class="number">1</span> || active &lt; leastActive) &#123; </span><br><span class="line">                <span class="comment">// 记录leastActive 为当前的活跃数</span></span><br><span class="line">                leastActive = active;</span><br><span class="line">                <span class="comment">//重置最小计数，基于当前最小计数重新计数</span></span><br><span class="line">                leastCount = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//在0下标出放入这个索引</span></span><br><span class="line">                leastIndexs[<span class="number">0</span>] = i; <span class="comment">// Reset</span></span><br><span class="line">                <span class="comment">// 总权重就是 当前invoker的权重</span></span><br><span class="line">                totalWeight = afterWarmup; </span><br><span class="line">                <span class="comment">//第一个权重</span></span><br><span class="line">                firstWeight = afterWarmup;</span><br><span class="line">                sameWeight = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (active == leastActive) &#123; <span class="comment">// 当前invoker的活跃数 与 leastActive相等</span></span><br><span class="line">                <span class="comment">// 记录索引位置，具有相同最小活跃数的计数器 +1</span></span><br><span class="line">                leastIndexs[leastCount++] = i;</span><br><span class="line">                <span class="comment">//总权重 =  总权重+当前权重</span></span><br><span class="line">                totalWeight += afterWarmup; <span class="comment">// Add this invoker's weight to totalWeight.</span></span><br><span class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; afterWarmup != firstWeight) &#123;</span><br><span class="line">                    sameWeight = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;<span class="comment">//如果我们恰好有一个调用程序具有最少的活动值，那么直接返回这个调用程序。</span></span><br><span class="line">            <span class="keyword">return</span> invokers.get(leastIndexs[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果每个invoker有不同的权重 &amp;&amp;  totalWeight &gt; 0</span></span><br><span class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 在totalWeight 范围内随机一个值</span></span><br><span class="line">            <span class="keyword">int</span> offsetWeight = random.nextInt(totalWeight) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取i位置的那个最小活跃 在invokers 里面的位置信息</span></span><br><span class="line">                <span class="keyword">int</span> leastIndex = leastIndexs[i];</span><br><span class="line">                <span class="comment">//offsetWeight - leastIndex 位置invoker的权重</span></span><br><span class="line">                offsetWeight -= getWeight(invokers.get(leastIndex), invocation);</span><br><span class="line">                <span class="comment">// offsetWeight 小于0的话</span></span><br><span class="line">                <span class="keyword">if</span> (offsetWeight &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 返回这个位置的这个</span></span><br><span class="line">                    <span class="keyword">return</span> invokers.get(leastIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 具有相同权重或者是 总权重=0 的话就均匀返回</span></span><br><span class="line">        <span class="comment">// If all invokers have the same weight value or totalWeight=0, return evenly.</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(leastIndexs[random.nextInt(leastCount)]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最小活跃算法很好理解，第一个判断逻辑<code>leastActive == -1 || active &lt; leastActive</code>会处理第一个invoker或者是最不活跃的一个invoker，并把它存储到数组下标为0的位置上。也就是循环过程中会得到一个<code>leastIndexs</code>数组，记录了当前最不活跃的invoker list。</p><p>后面的处理就是判断当前的list中是否有多个invoker或者存在不同权重的情况，这里的invoker选取就和<code>RandomLoadBalance</code>逻辑完全一致。</p><h2 id="五、ConsistentHashLoadBalance"><a href="#五、ConsistentHashLoadBalance" class="headerlink" title="五、ConsistentHashLoadBalance"></a>五、ConsistentHashLoadBalance</h2><p>​    分布式系统中，可以通过Hash算法让固定的一部分请求落在同一台服务器上，这样每台服务器就会固定处理一部分请求，从而起到负载均衡的作用。</p><p>​    但是普通的Hash算法缺乏伸缩性，当新增或者下线服务器机器时，简单通过散列的方式去负载均衡就会导致原有的映射关系大量失效。<strong>一致性Hash</strong>则通过Hash环进行了优化修改。</p><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>首先假设存在4台服务器分别为Ip1-4:</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230311165622760.png" alt="image-20230311165622760"></p><p>计算四台服务器ip地址对应的Hash值，计算出来的Hash值时0～最大正整数之间的一个值，对应hash环上的位置如上图所示👆</p><p>当用户在客户端发起请求时，会根据hash计算路由规则，计算出一个Hash值，然后看这个Hash值落在了Hash环的哪个地方，再根据Hash值在Hash环上的位置顺时针找到距离最近的IP作为路由IP。</p><p>如图：</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230311165650267.png" alt="image-20230311165650267"></p><p>假设此时ip3机器宕机,那么此时的请求分布情况应该是这样的👇：</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230311170323499.png" alt="image-20230311170323499"></p><p>原本的u1请求会从原来的ip3机器重新分配到ip4机器上，而之前没有分配到ip3机器上的请求不会受到影响。</p><p>假设我们增加了一个ip5的机器，这个机器在hash环上的位置在ip2和ip3之间，那么在环上的分布情况应该如下图所示👇：</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230311171214857.png" alt="image-20230311171214857"></p><p>新增加的ip5的机器会分摊一部分ip3的机器的请求，如果u1的请求在ip5和ip2之间，那么请求就会重新分配到ip5机器上处理。</p><h3 id="一致性Hash的特性"><a href="#一致性Hash的特性" class="headerlink" title="一致性Hash的特性"></a>一致性Hash的特性</h3><ul><li><strong>单调性（Monotonicity）</strong>：单调性指在新服务器加入到系统中时，应当保证原有的请求可以被映射到原有和新增的服务器上，而不会映射到原有的其他服务器上。</li><li><strong>分散性（Spread）</strong>：在分布式环境中，当客户端请求时可能不知道所有服务器的存在，可能只知道其中一部分服务器，从客户端看来，它看到的部分服务器会形成一个完整的Hash环。如果多个客户端都把部分服务器作为一个完整Hash环，那么可能会导致同一个用户的请求被路由到不同的服务器进行处理。这种情况显然是应该避免的，因为它不能保证同一个用户的请求落到同一台服务器。所谓分散性是指上述情况发生的严重程度。</li><li><strong>平衡性（Balance）</strong>：平衡性指负载均衡，指客户端Hash后的请求应该能分散到不同的服务器上。</li></ul><h3 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h3><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230311173641982.png" alt="image-20230311173641982"></p><p>假设经过计算后的Hash值在环上分布不均匀，那么就会导致上图的情况，会使得ip1机器处理更多的请求，而ip2和ip3只会负责少量的请求，这样就出现了一致性Hash的倾斜。</p><p>解决一致性Hash倾斜问题的解决方式一种是简单粗暴的加机器解决，但是增加机器是有成本的，那么就需要虚拟节点来解决。如图，每台机器增加一个虚拟节点之后的一致性Hash环如图所示：</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230311174009199.png" alt="image-20230311174009199"></p><p>这样就使得请求相对均匀的分布在三台机器上。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">     String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">     <span class="comment">// 拼接key</span></span><br><span class="line">     String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">"."</span> + methodName;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 计算hash</span></span><br><span class="line">     <span class="keyword">int</span> identityHashCode = System.identityHashCode(invokers);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 根据key 从缓存中获取ConsistentHashSelector</span></span><br><span class="line">     ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">     <span class="keyword">if</span> (selector == <span class="keyword">null</span> || selector.identityHashCode != identityHashCode) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 创建ConsistentHashSelector 放入缓存中</span></span><br><span class="line">         selectors.put(key, <span class="keyword">new</span> ConsistentHashSelector&lt;T&gt;(invokers, methodName, identityHashCode));</span><br><span class="line">         <span class="comment">// 获取新的selector</span></span><br><span class="line">         selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> selector.select(invocation);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以上代码主要是通过invoker来计算获取对应的selector，主要的负载均衡逻辑应当都是由selector来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   ConsistentHashSelector构造方法</span></span><br><span class="line">ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, <span class="keyword">int</span> identityHashCode) &#123;</span><br><span class="line">            <span class="comment">// 虚拟的invoker</span></span><br><span class="line">            <span class="keyword">this</span>.virtualInvokers = <span class="keyword">new</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line">            <span class="comment">// hashcode</span></span><br><span class="line">            <span class="keyword">this</span>.identityHashCode = identityHashCode;</span><br><span class="line">            <span class="comment">// 获取url</span></span><br><span class="line">            URL url = invokers.get(<span class="number">0</span>).getUrl();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取hash.nodes ，缺省是160 可以指定</span></span><br><span class="line">            <span class="keyword">this</span>.replicaNumber = url.getMethodParameter(methodName, <span class="string">"hash.nodes"</span>, <span class="number">160</span>);</span><br><span class="line">            <span class="comment">// 获取hash.arguments 缺省是0 然后进行切割</span></span><br><span class="line">            String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, <span class="string">"hash.arguments"</span>, <span class="string">"0"</span>));</span><br><span class="line">            argumentIndex = <span class="keyword">new</span> <span class="keyword">int</span>[index.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index.length; i++) &#123;</span><br><span class="line">                argumentIndex[i] = Integer.parseInt(index[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">                <span class="comment">// 获取地址 双层嵌套循环</span></span><br><span class="line">                String address = invoker.getUrl().getAddress();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; replicaNumber / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] digest = md5(address + i);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                        <span class="keyword">long</span> m = hash(digest, h);<span class="comment">//计算位置</span></span><br><span class="line">                        virtualInvokers.put(m, invoker);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里主要是对每个method创建一个<code>virtualInvokers</code>的treeMap用来存储虚拟节点，key就是计算出来的hash值，value就是invoker。</p><blockquote><p>  这里的双层循环的具体算法：</p><p>  <a href="https://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Consistent_hashing</a></p></blockquote><p><code>ConsistentHashSelector</code>的<code>invoker()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(Invocation invocation)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 将参数转成key</span></span><br><span class="line">          String key = toKey(invocation.getArguments());</span><br><span class="line">          <span class="keyword">byte</span>[] digest = md5(key);</span><br><span class="line">          <span class="keyword">return</span> selectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> String <span class="title">toKey</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">          StringBuilder buf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i : argumentIndex) &#123;</span><br><span class="line">              <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; args.length) &#123;</span><br><span class="line">                  buf.append(args[i]);<span class="comment">// 参数</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> buf.toString();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">selectForKey</span><span class="params">(<span class="keyword">long</span> hash)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//tailMap 是返回键值大于或等于key的那部分 ，然后再取第一个</span></span><br><span class="line">          Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry = virtualInvokers.tailMap(hash, <span class="keyword">true</span>).firstEntry();</span><br><span class="line">          <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;<span class="comment">//如果没有取到的话就说明hash就是最大的了，下面那个就是 treemap 第一个了</span></span><br><span class="line">              entry = virtualInvokers.firstEntry();</span><br><span class="line">          &#125;<span class="comment">// 返回对应的那个invoker</span></span><br><span class="line">          <span class="keyword">return</span> entry.getValue();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>主要是通过<code>tailMap()</code>方法找到返回键值大于或等于key的部分，然通过<code>firstEntry()</code>取第一个。</p><h2 id="六、基于扩展接口实现自定义负载均衡策略"><a href="#六、基于扩展接口实现自定义负载均衡策略" class="headerlink" title="六、基于扩展接口实现自定义负载均衡策略"></a>六、基于扩展接口实现自定义负载均衡策略</h2><p>​     自定义扩展实现，首先需要实现LoadBalance接口，由于Dubbo本身提供了一个抽象类AbstractLoadBalance，所以我们可以直接继承该类并且实现<code>doSelect()</code>方法：<br><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230311182131266.png" alt="image-20230311182131266"></p><p>以上！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lag Compensation - 网络游戏中的延迟补偿</title>
      <link href="/2023/02/05/Lag-Compensation-%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%BB%B6%E8%BF%9F%E8%A1%A5%E5%81%BF/"/>
      <url>/2023/02/05/Lag-Compensation-%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%BB%B6%E8%BF%9F%E8%A1%A5%E5%81%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="零、The-Server-Is-The-Man"><a href="#零、The-Server-Is-The-Man" class="headerlink" title="零、The Server Is The Man"></a>零、The Server Is The Man</h2><p>网络游戏中有一个铁律：<strong>“The Server Is The Man”</strong></p><blockquote><p>  <em>From the above, the server’s game state is completely and concisely defined by the set of all variables of all actors within a level. Because the server is authoritative about the game play flow, the server’s game state can always be regarded as the one true game state. The version of the game state on client machines should always be regarded as an approximation subject to many different kinds of deviations from the server’s game state. Actors that exist on the client machine should be considered proxies because they are a temporary, approximate representation of an object rather than the object itself.</em></p><p>  <em>When a client loads a Level to use in a networked multiplayer game, it deletes all Actors in the Level except those that have either bNoDelete set to true or bStatic set to true. Other Actors relevant to that client (as determined by the server) will be replicated from the server to the client. Some Actors (such as the GameInfo Actor) are never replicated to a client.</em></p><p>  <em>出自Unreal（Epic虚幻引擎）<a href="https://docs.unrealengine.com/udk/Three/NetworkingOverview.html" target="_blank" rel="noopener">https://docs.unrealengine.com/udk/Three/NetworkingOverview.html</a></em></p></blockquote><p>大意为服务器即服务端对游戏有绝对权威的掌控，游戏中的一切状态都要以服务器中所记录的为准。</p><h2 id="一、客户端-服务端游戏架构（Client-Server-Game）"><a href="#一、客户端-服务端游戏架构（Client-Server-Game）" class="headerlink" title="一、客户端/服务端游戏架构（Client/Server Game）"></a>一、客户端/服务端游戏架构（Client/Server Game）</h2><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/Lagcomp1.png" alt="Client/Server Game"></p><p>  目前大部分动作游戏都是经过修改后的 客户端 / 服务器游戏， 类似 <code>Half-Life</code> 半条命系列，以及其模组：大名鼎鼎的<code>Conter-Strike 反恐精英</code>系列。 </p><p>  在这些游戏中，通常有单独的一个<strong>权威主服务器来运行主游戏逻辑</strong>，为此<strong>链接一个或多个“无知”的客户端</strong>，客户端的指责最初不过是收集用户输入的指令，然后将其转发到服务端；随后服务端会执行这些指令，然后将执行结果发送会客户端，并在客户端呈现出运行的结果，例如在游戏中操纵游戏人物前进，也需要完成这样一个流程，将前进命令发向服务器，服务器接受前进指令，处理指令，将游戏人物前进后的坐标发往客户端，这样操纵游戏人物的玩家才真实的看到游戏角色向前走了一步。</p><p> 当然，在真实的游戏系统中需要很多组件的配合，而且也需要考虑<strong>预测和延迟滞后补偿</strong>。</p><h2 id="二、降低延迟影响"><a href="#二、降低延迟影响" class="headerlink" title="二、降低延迟影响"></a>二、降低延迟影响</h2><p>  网络游戏中，由于网络延迟或者网络状况的都懂，可能会对客户端的效果产生一定的扭曲，影响玩家体验。为了降低延迟带来的体验问题，一般有两种策略，一种是<strong>客户端预测</strong>，一种是<strong>延迟补偿</strong>。</p><h2 id="三、客户端预测"><a href="#三、客户端预测" class="headerlink" title="三、客户端预测"></a>三、客户端预测</h2><p>  客户端预测简单来说，就是在用户进行操作时，一方面客户端想服务端发送指令说明用户操作，另一方面客户端自己也会进行一定的预先行动，等到服务端确认之后，根据服务端返回的结果进行状态修正。也就是说当我们操纵游戏角色前进时，即使指令还未发送到服务器，我们在客户端也看到了游戏角色在向前移动。</p><p>  以魔兽世界 网游中的移动同步举例说明：</p><p>  客户端向服务端发送的网络包有三种类型：</p><ul><li>开始操作包：用户<strong>开始移动的信号</strong>，告诉服务端，目标何时从何地向哪里开始移动，方向多少；</li><li>心跳包：操作开始后，如果操作状态不发生变化，那么每隔一个<strong>心跳时间</strong>，向服务端发送心跳，表示我仍然处于上一个操作状态。</li><li><p>停止包：告知服务端，<strong>上一个操作状态停止</strong>，以及目标停留的位置。</p><p>简单来说就是当我们按下“向前”，发送操作包，持续按住，每一个心跳时间就发送一个心跳包，当改变方向或者停下，就发送一个停止包，再发送一个另一个方向的操作包。</p><p>服务器收到网络包后需要向其他玩家进行广播，但是会晚一个<strong>心跳时间</strong>，服务端端更新策略是：</p></li><li><p>收到操作包：等待一个心跳时间，将目标状态转为移动，并且发送包给其他客户端告知。</p></li><li>收到心跳包：更新一个心跳的位移，发包给其他客户端，同步目标坐标，这时其他客户端的任务也在移动，所以同步的代价很小，客户端看起来很流畅。</li><li>收到停止包：根据心跳包时间的比例，计算出最终坐标，与其他客户端同步。</li></ul><p>当出现网络延迟时：</p><p>操作人物前进时，由网络延迟的原因，<strong>持续的心跳包发送失败</strong>，所以在其他的客户端上，角色就会停在上一个心跳包的位置，等待下一个心跳包的到来，而且这时也会保持动画播放。这也就是我们在网游中经常看到其他网络差的玩家在原地跑动的情况。服务端没有收到心跳包，所以只会更新人物<strong>向前一个心跳包的位移</strong>，而不是持续更新，这样避免了类似“跳崖”之类的意外事件。客户端本地也会进行一个心跳的位移，这里也算是一种客户端预测的实现。</p><p>延迟结束之后，客户端收到延迟的包，发现需要同步的位移距离很大，这里就会选择让游戏角色“跑”过去或者直接瞬移到目标位置。</p><h2 id="四、延迟补偿"><a href="#四、延迟补偿" class="headerlink" title="四、延迟补偿"></a>四、延迟补偿</h2><p>  延迟补偿（Lag Compensation）的概念首次提出正是在游戏 <code>half-life</code> 之中，而且最知名的描述也来自于Valve v社的<em>Yahn W. Bernier</em>的文章：<strong>《Latency Compensating Methods in Client/Server In-game Protocol Design and Optimization》</strong></p><blockquote><p>  <em>Lag compensation is a method of normalizing server-side the state of the world for each player as that player’s user commands are executed. You can think of lag compensation as taking a step back in time, on the server, and looking at the state of the world at the exact instant that the user performed some action. The algorithm works as follows:</em></p><ol><li><p><em>Before executing a player’s current user command, the server:</em></p></li><li><ol><li><em>Computes a fairly accurate latency for the player</em></li><li><em>Searches</em> [<em>the server history</em>) <em>(for the current player) for the world update that was sent to the player and received by the player just before the player would have issued the movement command</em></li><li><em>From that update (and the one following it based on the exact target time being used), for each player in the update, move the other players backwards in time to exactly where they were when the      current player’s user command was created. This moving backwards must      account for both connection latency and the interpolation amount the      client was using that frame.</em></li></ol></li><li><p><em>Allow the user command to execute (including any weapon firing commands, etc., that will run ray casts against all of the other players in their “old” positions).</em></p></li><li><p><em>Move all of the moved/time-warped players back to their correct/current positions</em></p><p><em><a href="https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization" target="_blank" rel="noopener">https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization</a></em></p></li></ol></blockquote><p>  简单概括来说，就是服务器会考虑客户端的网络延迟，将服务器状态回滚到延迟之前，然后再次进行对指令的处理。</p><p>  算法原理：</p><ul><li>为所有的游戏玩家计算一个<strong>精准的延迟时间</strong>（ping值）</li><li>为当前玩家在服务器中<strong>查找当前玩家发出指令之前的所收到的上一个游戏内容更新指令</strong>；</li><li>对于当前最新发出的指令中涉及到的所有游戏玩家，都将他们在服务器中从上一更新指令开始计算，将他们<strong>同步到当前指令创建时的位置和状态</strong>（这种同步必须要考虑到客户端的插值运算和链接延迟）</li><li>开始允许玩家的<strong>指令执行</strong>(有时候可能会对对方玩家的“旧”位置进行影响，比如射击或者击杀）</li><li>最后将所有受影响的玩家<strong>同步更新到其正确的状态和位置</strong>。</li></ul><h2 id="五、服务器的通信频率（tickrate）"><a href="#五、服务器的通信频率（tickrate）" class="headerlink" title="五、服务器的通信频率（tickrate）"></a>五、服务器的通信频率（tickrate）</h2><p>  游戏过程是一个离散而非连续的过程，服务器会以一种频率向玩家的客户端进行通信来更新游戏状态。称之为服务器的通信频率，也就是csgo中我们常说的tickrate。官方服务器中一般为64tick，知名对战平台的都是128tick。</p><h2 id="六、CSGO中的延迟补偿"><a href="#六、CSGO中的延迟补偿" class="headerlink" title="六、CSGO中的延迟补偿"></a>六、CSGO中的延迟补偿</h2><p>csgo中的延迟补偿指令有两个：</p><ul><li>cl_interp</li><li>cl_interp_ratio</li></ul><h3 id="cl-interp"><a href="#cl-interp" class="headerlink" title="cl_interp"></a>cl_interp</h3><p>  可以这样理解：客户端显示的实时游戏画面是由服务器发送过来的包以及客户端预测互补组成。cl_interp是指服务器发送过来的连续两个包之间的间隔时长。客户端会根据连续两个包之间的间隔时长，更准确地进行预测。建议64tick下设置成0.015625（秒），128tick下设置成0.0078125（秒）。另外设置cl_interp的值为0或低于1/cl_updaterate值时，客户端也会自动生成最佳设置。</p><h3 id="cl-interp-ratio"><a href="#cl-interp-ratio" class="headerlink" title="cl_interp_ratio"></a>cl_interp_ratio</h3><p>  假设服务器发送过来的连续照片中的第10个网络包到达客户端后，决定客户端是否应该等待下一网络包到达，也就是第11个包也到达后，再把图像绘制在显示器上。也就是决定要不要延迟一个插帧周期再插帧。</p><p>  设置该值为1时，不会延迟一个周期，会立刻插帧。这样设置缺点明显，因为当遇到网络状况不佳时，如loss、延迟不稳定时，容易发生插帧丢失现象，表现为人物运动不连贯、卡、甚至瞬移。</p><p>  设置该值为2时，客户端在接收到服务器传送过来的一帧照片后，会等待一个周期，也就是等待0.015625秒之后（128tick为0.0078125秒），才会把照片所包含的信息转变为游戏画面。为什么要将服务器传送过来的画面延迟一个周期之后才显示呢？原因是这样的，为了避免预测图像出现误差，当客户端收到第一张照片后，等待一个周期，等收到了第二张照片后。结合两个照片所包含的信息，就可以更加精确的预测出两个照片之间的人物动作。这样预测出来的画面比较准确，可以说极大程度上修复了瞬移，卡，画面不连贯等情况。产生的延迟可以用延迟补偿功能弥补。</p><p>  指令的设置会对运动中的敌人爆头的手感产生影响，默认设置中，hitbox和人物模型是重合的，设置为立即插帧（cl_interp_ratio 1）后hitbox会因为客户端预测的原因实际手感会有一种hitbox在人物模型运动之前的感觉，并不是重合的。</p><h2 id="七、Peeker-‘s-Advantage"><a href="#七、Peeker-‘s-Advantage" class="headerlink" title="七、Peeker ‘s Advantage"></a>七、Peeker ‘s Advantage</h2><p>  在《彩虹六号：围攻》《CS:GO》等射击游戏中，先探头Peek的一方往往会获得极大的优势，这种情况称作「探头优势」即Peeker ‘s Advantage。先探头开枪的一方优势较大，而被动的一方在一瞬间被击杀，看击杀回放时又会发现自己在对方的视野中傻愣了很久。</p><p>  <img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/peekerAdvantage.png" alt="peeker advantage1"></p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/peekerAdvantage2.png" alt="peekerAdvantage2"></p><p>  假设P2是站着不动，<strong>P1是主动peek</strong>，P2的准确位置信息已经在P1看到P2之前就已经在P1的本地客户端作为判定依据了。当P1看到P2的时候，他看到的P2的位置就是当前时间P2的准确位置，因为P2没动。然而P2在此时此刻是看不到P1的，因为P1此时此刻的准确的位置信息还没有发送到P2的本地客户端，P2看到的是一段时间之前的P1的信息，这就导致在同一时刻，P1能看到P2而P2看不到P1。</p><p>  为了解决这种问题，或者减少Peeker ‘s Advantage，不同游戏都采用了不同的策略，例如人物的hitbox要比实际人物模型小，或者是csgo中我们常说的近大远小原则。</p><h2 id="八、引用"><a href="#八、引用" class="headerlink" title="八、引用"></a>八、引用</h2><blockquote><ul><li><a href="https://www.zhihu.com/question/29076648/answer/43726059" target="_blank" rel="noopener">https://www.zhihu.com/question/29076648/answer/43726059</a></li><li><a href="https://www.zhihu.com/question/263933628/answer/274629763" target="_blank" rel="noopener">https://www.zhihu.com/question/263933628/answer/274629763</a></li><li><a href="https://www.zhihu.com/question/20466492" target="_blank" rel="noopener">https://www.zhihu.com/question/20466492</a></li><li><a href="https://gafferongames.com/post/what_every_programmer_needs_to_know_about_game_networking/" target="_blank" rel="noopener">https://gafferongames.com/post/what_every_programmer_needs_to_know_about_game_networking/</a></li></ul></blockquote><p><strong>以上！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Networking </tag>
            
            <tag> CSGO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机统计信息监视工具 jstat</title>
      <link href="/2023/01/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF%E7%9B%91%E8%A7%86%E5%B7%A5%E5%85%B7-jstat/"/>
      <url>/2023/01/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF%E7%9B%91%E8%A7%86%E5%B7%A5%E5%85%B7-jstat/</url>
      
        <content type="html"><![CDATA[<h2 id="一、虚拟机统计信息监视工具-jstat"><a href="#一、虚拟机统计信息监视工具-jstat" class="headerlink" title="一、虚拟机统计信息监视工具 - jstat"></a>一、虚拟机统计信息监视工具 - jstat</h2><p>​    jstat(JVM Statistics Monitoring Tool)是用于监视虚拟机各种运行状态信息的<code>命令行工具</code>。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据. </p><p>​    <img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230123020509130.png" alt="image-20230123020509130" style="zoom:50%;" /></p><h2 id="二、命令参数"><a href="#二、命令参数" class="headerlink" title="二、命令参数"></a>二、命令参数</h2><p>​    通过上图的help帮助命令，可以看到 <em>jstat</em> 的通用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br><span class="line"><span class="meta">#</span><span class="bash">       参数     时间  每隔多少行   进程号    时间间隔     打印次数</span></span><br></pre></td></tr></table></figure><p>例如 需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次 那么命令就应该是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 2764 250 20</span><br></pre></td></tr></table></figure><h3 id="主要参数选项"><a href="#主要参数选项" class="headerlink" title="主要参数选项"></a>主要参数选项</h3><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230123025143977.png" alt="image-20230123025143977" style="zoom:50%;" /></p><p>或者通过 <code>jstat -options</code>来看我们到底支持哪些类型的数据</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230123025335605.png" alt="image-20230123025335605" style="zoom:50%;" /></p><blockquote><p>-class                类加载统计<br>-compiler                编译统计<br>-gc                垃圾回收统计<br>-gccapacity                堆内存统计<br>-gccause                近一次GC统计和原因<br>-gcmetacapacity                元数据空间统计<br>-gcnew                新生代垃圾回收统计<br>-gcnewcapacity                新生代内存统计<br>-gcold                老年代垃圾回收统计<br>-gcoldcapacity                老年代内存统计<br>-gcutil                垃圾回收统计(百分比)<br>-printcompilation                JVM编译方法统计</p></blockquote><p>option主要支持查询的内容主要分三类</p><ul><li>垃圾收集情况</li><li>类加载情况</li><li>运行期编译情况</li></ul><h2 id="三、垃圾收集"><a href="#三、垃圾收集" class="headerlink" title="三、垃圾收集"></a>三、垃圾收集</h2><p>​    垃圾收集情况的监视option主要是以下几种：</p><ul><li>-gc 垃圾回收统计</li><li>-gcnew 新生代垃圾回收统计</li><li>-gcold 老年代垃圾回收统计</li><li>-gcutil 垃圾回收统计(百分比)</li></ul><h3 id="使用-gcutil垃圾回收统计-百分比"><a href="#使用-gcutil垃圾回收统计-百分比" class="headerlink" title="使用-gcutil垃圾回收统计(百分比)"></a>使用<code>-gcutil</code>垃圾回收统计(百分比)</h3><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230123030433772.png" alt="image-20230123030433772" style="zoom:50%;" /></p><h3 id="使用-gc垃圾回收统计"><a href="#使用-gc垃圾回收统计" class="headerlink" title="使用-gc垃圾回收统计"></a>使用<code>-gc</code>垃圾回收统计</h3><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230123030709826.png" alt="image-20230123030709826"></p><h3 id="使用-gcnew-新生代垃圾回收统计"><a href="#使用-gcnew-新生代垃圾回收统计" class="headerlink" title="使用-gcnew 新生代垃圾回收统计"></a>使用<code>-gcnew</code> 新生代垃圾回收统计</h3><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230123030649928.png" alt="image-20230123030649928"></p><h3 id="使用-gcold-老年代垃圾回收统计"><a href="#使用-gcold-老年代垃圾回收统计" class="headerlink" title="使用 -gcold  老年代垃圾回收统计"></a>使用 <code>-gcold</code>  老年代垃圾回收统计</h3><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230123030802319.png" alt="image-20230123030802319"></p><h3 id="参数含义"><a href="#参数含义" class="headerlink" title="参数含义"></a><strong>参数含义</strong></h3><blockquote><p>  S0C：第一个幸存区的大小<br>  S1C：第二个幸存区的大小<br>  S0U：第一个幸存区的使用大小<br>  S1U：第二个幸存区的使用大小<br>  EC：伊甸园区的大小<br>  EU：伊甸园区的使用大小<br>  OC：老年代大小<br>  OU：老年代使用大小<br>  MC：方法区大小<br>  MU：方法区使用大小<br>  CCSC:压缩类空间大小<br>  CCSU:压缩类空间使用大小<br>  GCT：垃圾回收消耗总时间<br>  YGC: Young GC 代表Minor GC次数；<br>  YGCT: Young GC Time 代表Minor GC耗时；<br>  FGC: Full GC 代表Full GC次数；<br>  FGCT：老年代垃圾回收消耗时间；<br>  GCT: GC Time 代表Minor &amp; Full GC共计耗时；<br>  TT:对象在新生代存活的次数<br>  MTT:对象在新生代存活的最大次数<br>  DSS: Desired survivor size,期望幸存者大小<br>  S0：第一个幸存区百分比<br>  S1：第二个幸存区百分比<br>  E:  Eden 代表伊甸区使用百分比；<br>  O: Old 代表老年代使用百分比；<br>  M: Metaspace 元空间<br>  CCS:压缩类空间利用率为百分比</p></blockquote><h2 id="四、类加载"><a href="#四、类加载" class="headerlink" title="四、类加载"></a>四、类加载</h2><h3 id="使用-class类加载统计"><a href="#使用-class类加载统计" class="headerlink" title="使用-class类加载统计"></a>使用<code>-class</code>类加载统计</h3><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230123035123294.png" alt="image-20230123035123294"></p><h3 id="参数含义-1"><a href="#参数含义-1" class="headerlink" title="参数含义"></a>参数含义</h3><blockquote><p>  Loaded:加载class的数量<br>  Bytes：所占用空间大小<br>  Unloaded：未加载数量<br>  Bytes:未加载占用空间<br>  Time：时间<br>  Compiled：编译任务的数目<br>  Failed：失败数量<br>  Invalid：不可用数量<br>  Time：时间<br>  FailedType：失败类型<br>  FailedMethod：失败的方法<br>  Size：方法生成的字节码的大小<br>  Type：编译类型<br>  Method 方法</p></blockquote><h2 id="五、运行期编译情况"><a href="#五、运行期编译情况" class="headerlink" title="五、运行期编译情况"></a>五、运行期编译情况</h2><h3 id="使用-compiler-编译情况"><a href="#使用-compiler-编译情况" class="headerlink" title="使用-compiler 编译情况"></a>使用<code>-compiler</code> 编译情况</h3><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230123035501310.png" alt="image-20230123035501310"></p><h3 id="使用-gccapacity堆内存统计"><a href="#使用-gccapacity堆内存统计" class="headerlink" title="使用 -gccapacity堆内存统计"></a>使用 <code>-gccapacity</code>堆内存统计</h3><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230123035613181.png" alt="image-20230123035613181"></p><h3 id="参数含义-2"><a href="#参数含义-2" class="headerlink" title="参数含义"></a>参数含义</h3><blockquote><p>  NGCMN：新生代最小容量<br>  NGCMX：新生代最大容量<br>  NGC：当前新生代容量<br>  S0C：第一个幸存区大小<br>  S1C：第二个幸存区的大小<br>  EC：伊甸园区的大小<br>  OGCMN：老年代最小容量<br>  OGCMX：老年代最大容量<br>  OGC：当前老年代大小<br>  OC:当前老年代大小<br>  MCMN:最小元数据容量<br>  MCMX：最大元数据容量<br>  MC：当前元数据空间大小<br>  CCSMN：最小压缩类空间大小<br>  CCSMX：最大压缩类空间大小<br>  CCSC：当前压缩类空间大小<br>  YGC：年轻代gc次数<br>  FGC：老年代GC次数<br>  S0CMX：最大幸存1区大小<br>  S1CMX：最大幸存2区大小<br>  ECMX：最大伊甸园区大小</p></blockquote><h2 id="六、原理"><a href="#六、原理" class="headerlink" title="六、原理"></a>六、原理</h2><p>​    在Java环境变量的目录下（我的电脑是在<code>/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/lib</code>)  这个目录下存在一个 <code>tool.jar</code>的jar包</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20230123040806063.png" alt="image-20230123040806063"></p><p>​    这个jar包里有一个<code>jstat_options</code> 的文件，这个文件里的内容节选一段关于<code>gcutil</code>的大概是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">option gcutil &#123;</span><br><span class="line">  column &#123;</span><br><span class="line">    header <span class="string">"^S0^"</span>    <span class="comment">/* Survivor 0 Space - Percent Used */</span></span><br><span class="line">    data (<span class="number">1</span>-((sun.gc.generation<span class="number">.0</span>.space<span class="number">.1</span>.capacity - sun.gc.generation<span class="number">.0</span>.space<span class="number">.1</span>.used)/sun.gc.generation<span class="number">.0</span>.space<span class="number">.1</span>.capacity)) * <span class="number">100</span></span><br><span class="line">    scale raw</span><br><span class="line">    align right</span><br><span class="line">    width <span class="number">6</span></span><br><span class="line">    format <span class="string">"0.00"</span></span><br><span class="line">  &#125;</span><br><span class="line">  column &#123;</span><br><span class="line">    header <span class="string">"^S1^"</span>    <span class="comment">/* Survivor 1 Space - Percent Used */</span></span><br><span class="line">    data (<span class="number">1</span>-((sun.gc.generation<span class="number">.0</span>.space<span class="number">.2</span>.capacity - sun.gc.generation<span class="number">.0</span>.space<span class="number">.2</span>.used)/sun.gc.generation<span class="number">.0</span>.space<span class="number">.2</span>.capacity)) * <span class="number">100</span></span><br><span class="line">    scale raw</span><br><span class="line">    align right</span><br><span class="line">    width <span class="number">6</span></span><br><span class="line">    format <span class="string">"0.00"</span></span><br><span class="line">  &#125;</span><br><span class="line">  column &#123;</span><br><span class="line">    header <span class="string">"^E^"</span>    <span class="comment">/* Eden Space - Percent Used */</span></span><br><span class="line">    data (<span class="number">1</span>-((sun.gc.generation<span class="number">.0</span>.space<span class="number">.0</span>.capacity - sun.gc.generation<span class="number">.0</span>.space<span class="number">.0</span>.used)/sun.gc.generation<span class="number">.0</span>.space<span class="number">.0</span>.capacity)) * <span class="number">100</span></span><br><span class="line">    align right</span><br><span class="line">    scale raw</span><br><span class="line">    width <span class="number">6</span></span><br><span class="line">    format <span class="string">"0.00"</span></span><br><span class="line">  &#125;</span><br><span class="line">  column &#123;</span><br><span class="line">    header <span class="string">"^O^"</span>    <span class="comment">/* Old Space - Percent Used */</span></span><br><span class="line">    data (<span class="number">1</span>-((sun.gc.generation<span class="number">.1</span>.space<span class="number">.0</span>.capacity - sun.gc.generation<span class="number">.1</span>.space<span class="number">.0</span>.used)/sun.gc.generation<span class="number">.1</span>.space<span class="number">.0</span>.capacity)) * <span class="number">100</span></span><br><span class="line">    align right</span><br><span class="line">    scale raw</span><br><span class="line">    width <span class="number">6</span></span><br><span class="line">    format <span class="string">"0.00"</span></span><br><span class="line">  &#125;</span><br><span class="line">  column &#123;</span><br><span class="line">    header <span class="string">"^M^"</span>    <span class="comment">/* Metaspace Space - Percent Used */</span></span><br><span class="line">    data (<span class="number">1</span>-((sun.gc.metaspace.capacity - sun.gc.metaspace.used)/sun.gc.metaspace.capacity)) * <span class="number">100</span></span><br><span class="line">    align right</span><br><span class="line">    width <span class="number">6</span></span><br><span class="line">    scale raw</span><br><span class="line">    format <span class="string">"0.00"</span></span><br><span class="line">  &#125;</span><br><span class="line">  column &#123;</span><br><span class="line">    header <span class="string">"^CCS^"</span>    <span class="comment">/* Compressed Class Space Space - Percent Used */</span></span><br><span class="line">    data (<span class="number">1</span>-((sun.gc.compressedclassspace.capacity - sun.gc.compressedclassspace.used)/sun.gc.compressedclassspace.capacity)) * <span class="number">100</span></span><br><span class="line">    align right</span><br><span class="line">    width <span class="number">6</span></span><br><span class="line">    scale raw</span><br><span class="line">    format <span class="string">"0.00"</span></span><br><span class="line">  &#125;</span><br><span class="line">  column &#123;</span><br><span class="line">    header <span class="string">"^YGC^"</span>    <span class="comment">/* Young Generation Collections */</span></span><br><span class="line">    data sun.gc.collector<span class="number">.0</span>.invocations</span><br><span class="line">    align right</span><br><span class="line">    width <span class="number">6</span></span><br><span class="line">    format <span class="string">"0"</span></span><br><span class="line">  &#125;</span><br><span class="line">  column &#123;</span><br><span class="line">    header <span class="string">"^YGCT^"</span>    <span class="comment">/* Young Generation Collection Time */</span></span><br><span class="line">    data sun.gc.collector<span class="number">.0</span>.time/sun.os.hrt.frequency</span><br><span class="line">    align right</span><br><span class="line">    scale sec</span><br><span class="line">    width <span class="number">8</span></span><br><span class="line">    format <span class="string">"0.000"</span></span><br><span class="line">  &#125;</span><br><span class="line">  column &#123;</span><br><span class="line">    header <span class="string">"^FGC^"</span>    <span class="comment">/* Full Collections */</span></span><br><span class="line">    data sun.gc.collector<span class="number">.1</span>.invocations</span><br><span class="line">    align right</span><br><span class="line">    width <span class="number">5</span></span><br><span class="line">    scale raw</span><br><span class="line">    format <span class="string">"0"</span></span><br><span class="line">  &#125;</span><br><span class="line">  column &#123;</span><br><span class="line">    header <span class="string">"^FGCT^"</span>    <span class="comment">/* Full Collection Time */</span></span><br><span class="line">    data sun.gc.collector<span class="number">.1</span>.time/sun.os.hrt.frequency</span><br><span class="line">    align right</span><br><span class="line">    scale sec</span><br><span class="line">    width <span class="number">8</span></span><br><span class="line">    format <span class="string">"0.000"</span></span><br><span class="line">  &#125;</span><br><span class="line">  column &#123;</span><br><span class="line">    header <span class="string">"^GCT^"</span>    <span class="comment">/* Total Garbage Collection Time */</span></span><br><span class="line">    data (sun.gc.collector<span class="number">.0</span>.time + sun.gc.collector<span class="number">.1</span>.time)/sun.os.hrt.frequency</span><br><span class="line">    align right</span><br><span class="line">    width <span class="number">8</span></span><br><span class="line">    scale sec</span><br><span class="line">    format <span class="string">"0.000"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的定义我们知道gcutil的每一列是什么意思，怎么计算出来的，其中类似<code>sun.gc.generation.0.space.0.capacity</code>这样的一些变量是jvm里创建并实时更新的值.</p><p><strong>以上！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Linux </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RateLimiter Guava限流工具类</title>
      <link href="/2021/10/24/RateLimiter-Guava%E9%99%90%E6%B5%81%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2021/10/24/RateLimiter-Guava%E9%99%90%E6%B5%81%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、限流"><a href="#一、限流" class="headerlink" title="一、限流"></a>一、限流</h2><p>​    限流是保护高并发系统的三把利器之一，另外两个是缓存和降级。限流在很多场景中用来限制并发和请求量，比如说秒杀抢购，保护自身系统和下游系统不被巨型流量冲垮等。<strong>服务降级、熔断本身也是限流的一种</strong></p><p>​    限流的目的是通过对并发访问/请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务或进行流量整形。</p><p>​    常用的限流方式和场景有：限制总并发数（比如数据库连接池、线程池）、限制瞬时并发数（如nginx的limit<em>conn模块，用来限制瞬时并发连接数，Java的Semaphore也可以实现）、限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit</em>req模块，限制每秒的平均速率）；其他还有如限制远程接口调用速率、限制MQ的消费速率。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。</p><h2 id="二、限流基础算法"><a href="#二、限流基础算法" class="headerlink" title="二、限流基础算法"></a>二、限流基础算法</h2><p>​    限流基础算法有两种：令牌桶算法、漏桶算法</p><h3 id="1-漏桶算法"><a href="#1-漏桶算法" class="headerlink" title="1)漏桶算法"></a>1)漏桶算法</h3><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/801753-20190824212037987-415810352.png" alt="801753-20190824212037987-415810352"></p><p>​    漏桶算法可以强制的<strong>限制数据的传输速率</strong>。漏桶算法原理为将请求先进入到一个漏桶里，然后人为设置一个最大的出水速率，保证漏桶的出水速率小于等于设置过的出水速率，当水流过大的时候就会直接溢出，也就是采取拒绝策略。漏桶算法的实现往往依赖于<strong>队列</strong>，请求到达如果队列未满则直接放入队列，然后有一个处理器按照固定频率从队列头取出请求进行处理。如果请求量大，则会导致队列满，那么新来的请求就会被抛弃。</p><p>​    算法的大致流程就是：</p><ul><li>存下请求</li><li>匀速处理</li><li>多余丢弃</li></ul><p>漏桶算法的缺点十分明显，因为漏桶算法是一种强制限制请求速率的方式，所以它无法处理<strong>突发的大流量</strong>，网络请求中突然激增的流量是十分常见的，而漏桶算法的策略可能是直接将请求丢弃，这是十分不合理的。</p><h3 id="2-令牌桶算法"><a href="#2-令牌桶算法" class="headerlink" title="2)令牌桶算法"></a>2)令牌桶算法</h3><p>​    令牌桶算法是网络流量整形（Traffic Shaping）和限流（Rate Limiting）中最常使用的一种算法，它可用于控制发送到网络上数据的数量并允许突发数据的发送。</p><p>​    令牌桶算法是对漏桶算法的一种改进；</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/081226107372877.png" alt="img"></p><p>​    令牌桶的处理过程大概是：</p><ul><li>系统固定速率产生令牌，然后将令牌放入令牌桶中</li><li>令牌桶有固定容量，令牌桶满了，再产生的令牌就会被丢弃</li><li>每次发生请求，都会从令牌桶中获取一个令牌，如果取到，请求通过；如果没取到，那么就拒绝请求</li></ul><p>​    令牌桶算法可以在一定程度上防止突发流量(<strong>平滑流出速率</strong>)。假设我们想要的速率是1000QPS，那么往桶中放令牌的速度就是1000个/s，假设第1秒只有800个请求，那意味着第2秒可以容许1200个请求，这就是<strong>一定程度</strong>突发流量的意思，反之我们看漏桶算法，第一秒只有800个请求，那么全部放过，第二秒这1200个请求将会被打回200个。（是在设置桶中令牌上限满足的情况下）</p><h2 id="三、RateLimiter"><a href="#三、RateLimiter" class="headerlink" title="三、RateLimiter"></a>三、RateLimiter</h2><h3 id="1、SmoothBursty-平滑突发限流"><a href="#1、SmoothBursty-平滑突发限流" class="headerlink" title="1、SmoothBursty 平滑突发限流"></a>1、SmoothBursty 平滑突发限流</h3><p>一段代码示例，令牌桶中放置5个令牌，模拟每秒最多5个请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuchanglin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: LimiterTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/10/25 1:11 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimiterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat FORMATTER = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRateLimiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RateLimiter rateLimiter = RateLimiter.create(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        Thread[] ts = <span class="keyword">new</span> Thread[THREAD_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            ts[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RateLimiterThread(rateLimiter), <span class="string">"RateLimiterThread-"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            ts[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> RateLimiter rateLimiter;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RateLimiterThread</span><span class="params">(RateLimiter rateLimiter)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.rateLimiter = rateLimiter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            rateLimiter.acquire(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() </span><br><span class="line">                               + <span class="string">"获取到了令牌，时间 = "</span> + FORMATTER.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testRateLimiter();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结果：</p><blockquote><p>RateLimiterThread-0获取到了令牌，时间 = 2021-10-25 01:23:23<br>RateLimiterThread-15获取到了令牌，时间 = 2021-10-25 01:23:23<br>RateLimiterThread-16获取到了令牌，时间 = 2021-10-25 01:23:23<br>RateLimiterThread-14获取到了令牌，时间 = 2021-10-25 01:23:23<br>RateLimiterThread-13获取到了令牌，时间 = 2021-10-25 01:23:24<br>RateLimiterThread-12获取到了令牌，时间 = 2021-10-25 01:23:24<br>RateLimiterThread-11获取到了令牌，时间 = 2021-10-25 01:23:24<br>RateLimiterThread-17获取到了令牌，时间 = 2021-10-25 01:23:24<br>RateLimiterThread-18获取到了令牌，时间 = 2021-10-25 01:23:24<br>RateLimiterThread-10获取到了令牌，时间 = 2021-10-25 01:23:25<br>RateLimiterThread-9获取到了令牌，时间 = 2021-10-25 01:23:25<br>RateLimiterThread-8获取到了令牌，时间 = 2021-10-25 01:23:25<br>RateLimiterThread-7获取到了令牌，时间 = 2021-10-25 01:23:25<br>RateLimiterThread-6获取到了令牌，时间 = 2021-10-25 01:23:25<br>RateLimiterThread-5获取到了令牌，时间 = 2021-10-25 01:23:26<br>RateLimiterThread-4获取到了令牌，时间 = 2021-10-25 01:23:26<br>RateLimiterThread-3获取到了令牌，时间 = 2021-10-25 01:23:26<br>RateLimiterThread-19获取到了令牌，时间 = 2021-10-25 01:23:26<br>RateLimiterThread-2获取到了令牌，时间 = 2021-10-25 01:23:26<br>RateLimiterThread-1获取到了令牌，时间 = 2021-10-25 01:23:27<br>RateLimiterThread-20获取到了令牌，时间 = 2021-10-25 01:23:27<br>RateLimiterThread-21获取到了令牌，时间 = 2021-10-25 01:23:27<br>RateLimiterThread-22获取到了令牌，时间 = 2021-10-25 01:23:27<br>RateLimiterThread-23获取到了令牌，时间 = 2021-10-25 01:23:27<br>RateLimiterThread-24获取到了令牌，时间 = 2021-10-25 01:23:28</p></blockquote><p>可以看到，每秒只有5个线程可以取到令牌。</p><ul><li>acquire会阻塞线程直到线程获取到令牌，返回值是一个double类型，表示从开始阻塞到获取到令牌的时间，单位为秒；</li><li>tryAquire可以指定超时时间，返回值为boolean类型；</li></ul><h3 id="RateLimiter-预消费"><a href="#RateLimiter-预消费" class="headerlink" title="RateLimiter 预消费"></a>RateLimiter 预消费</h3><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20211025021453432.png" alt="image-20211025021453432"></p><p>acquire方法有一个参数为permits的重载方法，它可以允许一次指定多个令牌数  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRateLimiterPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RateLimiter rateLimiter = RateLimiter.create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"获取1个令牌开始，时间为"</span> + FORMATTER.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    <span class="keyword">double</span> cost = rateLimiter.acquire(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"获取1个令牌结束，时间为"</span> + FORMATTER.format(<span class="keyword">new</span> Date()) + <span class="string">", 耗时"</span> + cost + <span class="string">"ms"</span>);</span><br><span class="line">    System.out.println(<span class="string">"获取5个令牌开始，时间为"</span> + FORMATTER.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    cost = rateLimiter.acquire(<span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">"获取5个令牌结束，时间为"</span> + FORMATTER.format(<span class="keyword">new</span> Date()) + <span class="string">", 耗时"</span> + cost + <span class="string">"ms"</span>);</span><br><span class="line">    System.out.println(<span class="string">"获取3个令牌开始，时间为"</span> + FORMATTER.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    cost = rateLimiter.acquire(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">"获取3个令牌结束，时间为"</span> + FORMATTER.format(<span class="keyword">new</span> Date()) + <span class="string">", 耗时"</span> + cost + <span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码输出结果👇🏻</p><blockquote><p>获取1个令牌开始，时间为2021-10-25 02:16:57<br>获取1个令牌结束，时间为2021-10-25 02:16:57, 耗时0.0ms<br>获取5个令牌开始，时间为2021-10-25 02:16:57<br>获取5个令牌结束，时间为2021-10-25 02:16:58, 耗时0.996506ms<br>获取3个令牌开始，时间为2021-10-25 02:16:58<br>获取3个令牌结束，时间为2021-10-25 02:17:03, 耗时4.994537ms</p></blockquote><p>从结果上看，如果请求的数量大于防止令牌的数量，那么这是可以允许处理的，但是影响就是后续的请求就要延后处理。</p><h3 id="2、SmoothWarmingUp-平滑预热限流"><a href="#2、SmoothWarmingUp-平滑预热限流" class="headerlink" title="2、SmoothWarmingUp 平滑预热限流"></a>2、SmoothWarmingUp 平滑预热限流</h3><p>RateLimiter 还具有平滑预热限流的使用方式，通过<code>create</code>方法中的参数配置，可以指定RateLimiter的一段预热时间👇：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSmoothWarmingUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里是指每秒2个令牌 3秒预热时间</span></span><br><span class="line">        RateLimiter r = RateLimiter.create(<span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"get 1 tokens: "</span> + r.acquire(<span class="number">1</span>) + <span class="string">"s"</span>);</span><br><span class="line">            System.out.println(<span class="string">"get 1 tokens: "</span> + r.acquire(<span class="number">1</span>) + <span class="string">"s"</span>);</span><br><span class="line">            System.out.println(<span class="string">"get 1 tokens: "</span> + r.acquire(<span class="number">1</span>) + <span class="string">"s"</span>);</span><br><span class="line">            System.out.println(<span class="string">"get 1 tokens: "</span> + r.acquire(<span class="number">1</span>) + <span class="string">"s"</span>);</span><br><span class="line">            System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码的运行结果如下：</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20220203173304426.png" alt="image-20220203173304426" style="zoom:50%;" /></p><p>​    我们可以看到前三次令牌的获取就耗时了总共约3s的时间，这代表RateLimiter在前三秒处于预热状态，并不是一开始我们期望的每秒2个令牌的速率。</p><p>​    平滑预热限流适用于资源需要预热的场景，比如服务启动时数据库连接还没有加载完成，这个情况下如果大批量的请求进入就会给服务带来不必要的压力，一个预热的限流就可以避免这样的问题发生。</p><h3 id="RateLimiter的限制"><a href="#RateLimiter的限制" class="headerlink" title="RateLimiter的限制"></a>RateLimiter的限制</h3><p>​    RateLimiter 是单机的如果需要对集群进行限流，就需要借助于Redis、sentinel等来实现；</p><h2 id="四、源码"><a href="#四、源码" class="headerlink" title="四、源码"></a>四、源码</h2><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20211025023935179.png" alt="image-20211025023935179" style="zoom:50%;" /></p><p>首先作为抽象父类的<code>RateLimiter</code>只有两个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RateLimiter.SleepingStopwatch stopwatch;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Object mutexDoNotUseDirectly;</span><br></pre></td></tr></table></figure><p>​    这两个属性中的 stopwatch用于 计时 ，其他逻辑中关于时间的计算基本上都是由它来完成的，另外一个mutexDoNotUserDirectly用来做锁，RateLimiter 依赖于 synchronized 来控制并发，各个属性甚至都没有用 volatile 修饰。    </p><p>​    之后在<code>SmoothRateLimiter</code>中负责实现大部分方法和逻辑，它的属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SmoothRateLimiter.java</span></span><br><span class="line"><span class="comment">//当前存储令牌数</span></span><br><span class="line"><span class="keyword">double</span> storedPermits;</span><br><span class="line"><span class="comment">//最大存储令牌数</span></span><br><span class="line"><span class="keyword">double</span> maxPermits;</span><br><span class="line"><span class="comment">//添加令牌时间间隔</span></span><br><span class="line"><span class="keyword">double</span> stableIntervalMicros;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下一次请求可以获取令牌的起始时间</span></span><br><span class="line"><span class="comment"> * 由于RateLimiter允许预消费，上次请求预消费令牌后</span></span><br><span class="line"><span class="comment"> * 下次请求需要等待相应的时间到nextFreeTicketMicros时刻才可以获取令牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> nextFreeTicketMicros = <span class="number">0L</span>;</span><br></pre></td></tr></table></figure><h3 id="1、平滑突发限流-SmoothBursty-分析"><a href="#1、平滑突发限流-SmoothBursty-分析" class="headerlink" title="1、平滑突发限流 SmoothBursty 分析"></a>1、平滑突发限流 SmoothBursty 分析</h3><p>​    首先是平滑突发限流的<code>RateLimiter</code>的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(<span class="keyword">double</span> permitsPerSecond)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(permitsPerSecond, RateLimiter.SleepingStopwatch.createFromSystemTimer());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, RateLimiter.SleepingStopwatch stopwatch)</span> </span>&#123;</span><br><span class="line">    RateLimiter rateLimiter = <span class="keyword">new</span> SmoothBursty(stopwatch, <span class="number">1.0</span>D <span class="comment">/* maxBurstSeconds */</span>);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond); <span class="comment">// setRate</span></span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以看到平滑突发限流就是对子类SmoothBursty的实现</p><p>​    SmoothBursty 有一个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数指定了 maxBurstSeconds 为 1.0，也就是说，最多会缓存 1 秒钟，</span></span><br><span class="line"><span class="comment"> * 也就是 (1.0 * permitsPerSecond) 这么多个 permits 到池中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> maxBurstSeconds;</span><br></pre></td></tr></table></figure><p>​    这个属性在<code>create</code>方法中已经被指定为1；</p><p>​    接下来看<code>setRate</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pulic 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond)</span> </span>&#123;</span><br><span class="line">        Preconditions.checkArgument(permitsPerSecond &gt; <span class="number">0.0</span>D &amp;&amp; !Double.isNaN(permitsPerSecond), <span class="string">"rate must be positive"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.mutex()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doSetRate(permitsPerSecond, <span class="keyword">this</span>.stopwatch.readMicros());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resync(nowMicros);</span><br><span class="line">        <span class="keyword">double</span> stableIntervalMicros = (<span class="keyword">double</span>)TimeUnit.SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;</span><br><span class="line">        <span class="keyword">this</span>.stableIntervalMicros = stableIntervalMicros;</span><br><span class="line">        <span class="keyword">this</span>.doSetRate(permitsPerSecond, stableIntervalMicros);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    setRate首先进行了参数的校验，然后这里的<code>resync</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (nowMicros &gt; <span class="keyword">this</span>.nextFreeTicketMicros) &#123;</span><br><span class="line">         <span class="comment">// coolDownIntervalMicros 这里的这个方法返回的就是添加令牌时间间隔</span></span><br><span class="line">           <span class="keyword">double</span> newPermits = (<span class="keyword">double</span>)(nowMicros - <span class="keyword">this</span>.nextFreeTicketMicros) / <span class="keyword">this</span>.coolDownIntervalMicros();</span><br><span class="line">           <span class="keyword">this</span>.storedPermits = Math.min(<span class="keyword">this</span>.maxPermits, <span class="keyword">this</span>.storedPermits + newPermits);</span><br><span class="line">           <span class="keyword">this</span>.nextFreeTicketMicros = nowMicros;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>resync方法就是将当前时间作为参数，判断当前时间是否大于‘下次可以获取令牌‘的时间，通过这种方式来重新刷新令牌池中可供使用的令牌数量，</p><blockquote><p>在 SmoothBursty 类中的实现是直接返回了 stableIntervalMicros 的值，也就是我们说的，每产生一个 permit 的时间长度。</p><p>在构造方法中调用的resync 此时的 stableIntervalMicros 其实没有设置，也就是说，上面发生了一次除以 0 值的操作，得到的 newPermits 其实是一个无穷大。而 maxPermits 此时还是 0 值，不过这里其实没有关系。</p></blockquote><p>resync方法执行完成后，对<code>stableIntervalMicros</code>进行了赋值，这里又进行了一次setRate：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> stableIntervalMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> oldMaxPermits = <span class="keyword">this</span>.maxPermits;</span><br><span class="line">    <span class="keyword">this</span>.maxPermits = <span class="keyword">this</span>.maxBurstSeconds * permitsPerSecond;</span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == <span class="number">1.0</span>D / <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.storedPermits = <span class="keyword">this</span>.maxPermits;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.storedPermits = oldMaxPermits == <span class="number">0.0</span>D ? <span class="number">0.0</span>D : <span class="keyword">this</span>.storedPermits * <span class="keyword">this</span>.maxPermits / oldMaxPermits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    因为setRate是一个public方法，所以在RateLimiter创建初始化之后也可以通过这个方法来动态的调整它的速率，这部分初始化了maxPermits参数，并且也对storedPermits参数进行了调整，可以看到调用一次setRate对于 maxPermits 来说，是重新计算，而对于 storedPermits 来说，是做等比例的缩放。</p><p>​    初始化的代码基本到此就结束了，接下来是acquire部分，RateLimiter是怎样通过计算时间的方式来提供一个有效的令牌的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CanIgnoreReturnValue</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.acquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CanIgnoreReturnValue</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算需要sleep等待的时间</span></span><br><span class="line">      <span class="keyword">long</span> microsToWait = <span class="keyword">this</span>.reserve(permits);</span><br><span class="line">     <span class="comment">// sleep</span></span><br><span class="line">      <span class="keyword">this</span>.stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">    <span class="comment">// 返回sleep的时间</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1.0</span>D * (<span class="keyword">double</span>)microsToWait / (<span class="keyword">double</span>)TimeUnit.SECONDS.toMicros(<span class="number">1L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算需要sleep等待的时间</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">      checkPermits(permits); <span class="comment">// 检查是否是一个有效的permits参数</span></span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>.mutex()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.reserveAndGetWaitLength(permits, <span class="keyword">this</span>.stopwatch.readMicros());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveAndGetWaitLength</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> momentAvailable = <span class="keyword">this</span>.reserveEarliestAvailable(permits, nowMicros);</span><br><span class="line">      <span class="keyword">return</span> Math.max(momentAvailable - nowMicros, <span class="number">0L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveEarliestAvailable</span><span class="params">(<span class="keyword">int</span> requiredPermits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.resync(nowMicros); <span class="comment">// 刷新令牌池</span></span><br><span class="line">      <span class="keyword">long</span> returnValue = <span class="keyword">this</span>.nextFreeTicketMicros; <span class="comment">// 下次可以取到令牌的时间</span></span><br><span class="line">    <span class="comment">// 计算在当前令牌池中需要使用的令牌数量[请求的令牌数可能大于当前令牌池中的有效令牌数，预消费逻辑]</span></span><br><span class="line">      <span class="keyword">double</span> storedPermitsToSpend = Math.min((<span class="keyword">double</span>)requiredPermits, <span class="keyword">this</span>.storedPermits);</span><br><span class="line">    <span class="comment">// 计算预消费中不够的部分</span></span><br><span class="line">      <span class="keyword">double</span> freshPermits = (<span class="keyword">double</span>)requiredPermits - storedPermitsToSpend;</span><br><span class="line">      <span class="comment">// storedPermitsToWaitTime 在平滑突发限流模式中默认返回为0</span></span><br><span class="line">    <span class="comment">// 计算总共需要等待的时间</span></span><br><span class="line">      <span class="keyword">long</span> waitMicros = <span class="keyword">this</span>.storedPermitsToWaitTime(<span class="keyword">this</span>.storedPermits, storedPermitsToSpend) + (<span class="keyword">long</span>)(freshPermits * <span class="keyword">this</span>.stableIntervalMicros);</span><br><span class="line">    <span class="comment">// 计算下次有有效令牌的具体时间，重新更新nextFreeTicketMicros</span></span><br><span class="line">      <span class="keyword">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(<span class="keyword">this</span>.nextFreeTicketMicros, waitMicros);</span><br><span class="line">      <span class="keyword">this</span>.storedPermits -= storedPermitsToSpend;</span><br><span class="line">      <span class="keyword">return</span> returnValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​    返回值是 nextFreeTicketMicros 的旧值，因为只要到这个时间点，就说明当次 acquire 可以成功返回了，而不管 storedPermits 够不够。如果 storedPermits 不够，会将 nextFreeTicketMicros 往前推一定的时间，预占了一定的量。</p><h3 id="2、平滑预热限流-SmoothWarmingUp-分析"><a href="#2、平滑预热限流-SmoothWarmingUp-分析" class="headerlink" title="2、平滑预热限流 SmoothWarmingUp 分析"></a>2、平滑预热限流 SmoothWarmingUp 分析</h3><p>​    <img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/format,png.png" alt="img"></p><p><em>X 轴代表 storedPermits 的数量，Y 轴代表获取一个 permits 需要的时间</em></p><blockquote><p>  假设指定 permitsPerSecond 为 10，那么 stableInterval 为 100ms，而 coldInterval 是 3 倍，也就是 300ms（coldFactor，3 倍是写死的，用户不能修改）。也就是说，当达到 maxPermits 时，此时处于系统最冷的时候，获取一个 permit 需要 300ms，而如果 storedPermits 小于 thresholdPermits 的时候，只需要 100ms。</p></blockquote><p>如图中所示，图中梯形所处的区域就代表预热时间，预热期间内获取一个permits的时间会相比于正常时间的stable interval要长，随着服务的启动获取permits的时间会趋于稳定。</p><ul><li>当系统在非常繁忙的时候，这条线停留在 x=0 处，此时 storedPermits 为 0</li><li>当 limiter 没有被使用的时候，这条线慢慢往右移动，直到 x=maxPermits 处；</li><li>如果 limiter 被重新使用，那么这条线又慢慢往左移动，直到 x=0 处，当 storedPermits 处于 maxPermits 状态时，我们认为 limiter 中的 permits 是冷的，此时获取一个 permit 需要较多的时间，因为需要预热，有一个关键的分界点是 <strong>thresholdPermits</strong>。</li></ul><p><strong>预热时间</strong>是创建RaterLimiter对象时指定的，所以我们需要通过预热时间计算出<strong>thresholdPermits</strong> 和 <strong>maxPermits</strong> 的值，由于图中x轴和y轴分别代表保存的令牌数量和获取令牌的时间，通过数学常识我门不难得出<strong>梯形的面积就是预热时间</strong>。</p><blockquote><p>  从 thresholdPermits 到 0 的时间，是从 maxPermits 到 thresholdPermits 时间的一半，也就是梯形的面积是长方形面积的 2 倍，梯形的面积是 warmupPeriod。（前提）之所以长方形的面积是 warmupPeriod/2，是因为 coldFactor 是硬编码的 3。</p></blockquote><p>由于梯形面积为warmupPeriod，且存在二倍关系，故有：</p><script type="math/tex; mode=display">warmupPeriod = 2 * stableInterval * thresholdPermits</script><p>亦得：</p><script type="math/tex; mode=display">thresholdPermits = 0.5 * warmupPeriod / stableInterval</script><p>梯形面积可通过梯形面积公式以下面的方式表示：</p><script type="math/tex; mode=display">warmupPeriod = 0.5 * (stableInterval + coldInterval) * (maxPermits - thresholdPermits)</script><p>整理后可以将maxPermits表示为：</p><script type="math/tex; mode=display">maxPermits = thresholdPermits + 2.0 * warmupPeriod / (stableInterval + coldInterval)</script><p>因为warmupPeriod是我们指定的，而且stableInterval可以通过计算得出，所以通过上述公式可以计算出thresholdPermits 和 maxPermits 的值。</p><p>​    冷却时间间隔，它指的是 storedPermits 中每个 permit 的增长速度，也就是我们前面说的 x=k 这条垂直线往右的移动速度，为了达到从 0 到 maxPermits 花费 warmupPeriodMicros 的时间，我们将其定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">coolDownIntervalMicros</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> warmupPeriodMicros / maxPermits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">    <span class="comment">// coolDownIntervalMicros 在这里使用</span></span><br><span class="line">    <span class="keyword">double</span> newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class="line">    storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">    nextFreeTicketMicros = nowMicros;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doset方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> stableIntervalMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> oldMaxPermits = maxPermits;</span><br><span class="line">    <span class="comment">// coldFactor 是固定的 3</span></span><br><span class="line">    <span class="keyword">double</span> coldIntervalMicros = stableIntervalMicros * coldFactor;</span><br><span class="line">    <span class="comment">// 这个公式上面已经说了</span></span><br><span class="line">    thresholdPermits = <span class="number">0.5</span> * warmupPeriodMicros / stableIntervalMicros;</span><br><span class="line">    <span class="comment">// 这个公式上面也已经说了</span></span><br><span class="line">    maxPermits =</span><br><span class="line">        thresholdPermits + <span class="number">2.0</span> * warmupPeriodMicros / (stableIntervalMicros + coldIntervalMicros);</span><br><span class="line">    <span class="comment">// 计算那条斜线的斜率。数学知识，对边 / 临边</span></span><br><span class="line">    slope = (coldIntervalMicros - stableIntervalMicros) / (maxPermits - thresholdPermits);</span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">        <span class="comment">// if we don't special-case this, we would get storedPermits == NaN, below</span></span><br><span class="line">        storedPermits = <span class="number">0.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        storedPermits =</span><br><span class="line">            (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">                ? maxPermits <span class="comment">// initial state is cold</span></span><br><span class="line">                : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aquire方法：</p><p>在 SmoothWarmingUp 的实现中，由于需要预热，所以从 storedPermits 中取 permits 需要花费一定的时间，首先要看一下这部分代码，这里是acquire的核心，也就是对等待时间的计算也就是<code>storedPermitsToWaitTime()</code>方法的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveEarliestAvailable</span><span class="params">(<span class="keyword">int</span> requiredPermits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">  resync(nowMicros);</span><br><span class="line">  <span class="keyword">long</span> returnValue = nextFreeTicketMicros;</span><br><span class="line">  <span class="keyword">double</span> storedPermitsToSpend = min(requiredPermits, <span class="keyword">this</span>.storedPermits);</span><br><span class="line">  <span class="keyword">double</span> freshPermits = requiredPermits - storedPermitsToSpend;</span><br><span class="line">  <span class="keyword">long</span> waitMicros =</span><br><span class="line">    <span class="comment">//这里计算等待时间</span></span><br><span class="line">      storedPermitsToWaitTime(<span class="keyword">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">          + (<span class="keyword">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);</span><br><span class="line">  <span class="keyword">this</span>.storedPermits -= storedPermitsToSpend;</span><br><span class="line">  <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待时间其实就是要计算下图中，阴影部分的面积。</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/format,png-20220723190946072.png" alt="img"></p><p>计算的过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">storedPermitsToWaitTime</span><span class="params">(<span class="keyword">double</span> storedPermits, <span class="keyword">double</span> permitsToTake)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> availablePermitsAboveThreshold = storedPermits - thresholdPermits;</span><br><span class="line">  <span class="keyword">long</span> micros = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 如果右边梯形部分有 permits，那么先从右边部分获取permits，计算梯形部分的阴影部分的面积</span></span><br><span class="line">  <span class="keyword">if</span> (availablePermitsAboveThreshold &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">    <span class="comment">// 从右边部分获取的 permits 数量</span></span><br><span class="line">    <span class="keyword">double</span> permitsAboveThresholdToTake = min(availablePermitsAboveThreshold, permitsToTake);</span><br><span class="line">    <span class="comment">// 梯形面积公式：(上底+下底)*高/2</span></span><br><span class="line">    <span class="keyword">double</span> length =</span><br><span class="line">        permitsToTime(availablePermitsAboveThreshold)</span><br><span class="line">            + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake);</span><br><span class="line">    micros = (<span class="keyword">long</span>) (permitsAboveThresholdToTake * length / <span class="number">2.0</span>);</span><br><span class="line">    permitsToTake -= permitsAboveThresholdToTake;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 加上 长方形部分的阴影面积</span></span><br><span class="line">  micros += (<span class="keyword">long</span>) (stableIntervalMicros * permitsToTake);</span><br><span class="line">  <span class="keyword">return</span> micros;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 对于给定的 x 值，计算 y 值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">permitsToTime</span><span class="params">(<span class="keyword">double</span> permits)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> stableIntervalMicros + permits * slope;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    至此，RateLimiter的平滑突发限流与平滑预热限流全部分析完毕！</p><p><strong>以上！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Guava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从CPU cache与缓存行到高性能队列Disruptor</title>
      <link href="/2021/04/03/%E4%BB%8ECPU-cache%E4%B8%8E%E7%BC%93%E5%AD%98%E8%A1%8C%E5%88%B0%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97Disruptor/"/>
      <url>/2021/04/03/%E4%BB%8ECPU-cache%E4%B8%8E%E7%BC%93%E5%AD%98%E8%A1%8C%E5%88%B0%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97Disruptor/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于CPU"><a href="#一、关于CPU" class="headerlink" title="一、关于CPU"></a>一、关于CPU</h2><p>​    CPU由三部分组成:</p><ul><li><strong>算术/逻辑单元(arithmetic/logic unit)</strong>:它包含在数据上执行运算(如加法和减法)的电路;</li><li><strong>控制单元(control unit)</strong>:它包含协调机器活动的电路;</li><li><strong>寄存器单元(register unit)</strong>:他包含称为寄存器(register)的数据存储单元(与主存单元相似),用作CPU内部的信息临时存储.</li></ul><p>寄存器单元中的一些寄存器被看成是<strong>通用寄存器(general-purpose register)</strong>,而其他的一些则被看成是<strong>专用寄存器(special-purpose register)</strong>.这里先关注通用寄存器.</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20210405003309699.png" alt="image-20210405003309699" style="zoom:50%;" /></p><p>​    基于这样的设计,将存储在主存储器上的两个值相加的任务不仅仅涉及到加法运算,数据必须先从主存储器传输到CPU到寄存器中,相加后再把结果放在主存储器单元中.</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20210405005759994.png" alt="image-20210405005759994" style="zoom:50%;" /></p><p>​    <strong>存储程序概念(stored-program concept)</strong>，这个概念即将计算机程序存储到主存储器中，每次处理任务，只需要访问存储器中的计算机程序进行处理即可，而不需要对CPU进行重新布线。</p><p>CPU中有两个专用寄存器:</p><ul><li><strong>指令寄存器(instruction register)</strong>     :用来存储正在执行的指令</li><li><strong>程序计数器(program counter)</strong>     :用来存储下一个等待执行的指令的地址.用于追踪程序执行到了什么地方.</li></ul><p>CPU通过不断重复一个算法来完成他的任务,这个算法引导CPU完成一个叫<strong>机器周期(machine cycle)</strong>的三步处理.</p><p>描述CPU计算能力的时钟频率<strong>以赫兹为单位</strong>,1Hz<strong>相当于每秒一个周期</strong>.</p><h2 id="二、CPU-Cache"><a href="#二、CPU-Cache" class="headerlink" title="二、CPU Cache"></a>二、CPU Cache</h2><blockquote><p>​    在<a href="https://zh.wikipedia.org/wiki/计算机" target="_blank" rel="noopener">计算机</a>系统中，<strong>CPU高速缓存</strong>（英语：CPU Cache）是用于减少<a href="https://zh.wikipedia.org/wiki/中央处理器" target="_blank" rel="noopener">处理器</a>访问内存所需平均时间的部件。在金字塔式<a href="https://zh.wikipedia.org/w/index.php?title=存储体系&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">存储体系</a>中它位于自顶向下的第二层，仅次于<a href="https://zh.wikipedia.org/wiki/寄存器" target="_blank" rel="noopener">CPU寄存器</a>。其容量远小于<a href="https://zh.wikipedia.org/wiki/内存" target="_blank" rel="noopener">内存</a>，但速度却可以接近处理器的频率。</p><p>​    当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器。</p><p>​    缓存之所以有效，主要是因为程序运行时对内存的访问呈现<strong>局部性（Locality）</strong>特征。这种局部性既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality）。有效利用这种局部性，缓存可以达到极高的命中率。</p><p>​    在处理器看来，缓存是一个透明部件。因此，程序员通常无法直接干预对缓存的操作。但是，确实可以根据缓存的特点对程序代码实施特定优化，从而更好地利用缓存。</p><p>​                                                                                                                                                                    —维基百科</p></blockquote><h3 id="1-为什么要有CPU-Cache"><a href="#1-为什么要有CPU-Cache" class="headerlink" title="#1 为什么要有CPU Cache"></a>#1 为什么要有CPU Cache</h3><p>​    随着工艺的提升最近几十年CPU的频率不断提升，而受制于制造工艺和成本限制，目前计算机的内存主要是DRAM并且在访问速度上没有质的突破。因此，<strong>CPU的处理速度和内存的访问速度差距越来越大，甚至可以达到上万倍</strong>。这种情况下传统的CPU通过FSB直连内存的方式显然就会因为内存访问的等待，导致计算资源大量闲置，降低CPU整体吞吐量。同时又由于内存数据访问的热点集中性，在CPU和内存之间用较为快速而成本较高的SDRAM做一层缓存，就显得性价比极高了。</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/10538467-7923f58c663c7db1.png" alt="img"  /></p><h3 id="2-为什么要有多级CPU-Cache"><a href="#2-为什么要有多级CPU-Cache" class="headerlink" title="#2 为什么要有多级CPU Cache"></a>#2 为什么要有多级CPU Cache</h3><blockquote><p>多级cpu缓存速度对比；</p><ol><li>各种寄存器，用来存储本地变量和函数参数，访问一次需要 1cycle，耗时小于 1ns；</li><li>L1 Cache，一级缓存，本地 core 的缓存，分成 32K 的数据缓存 L1d 和 32k 指令缓存 L1i，访问 L1 需要 3cycles，耗时大约 1ns；</li><li>L2 Cache，二级缓存，本地 core 的缓存，被设计为 L1 缓存与共享的 L3 缓存之间的缓冲，大小为 256K，访问 L2 需要 12cycles，耗时大约 3ns；</li><li>L3 Cache，三级缓存，在同插槽的所有 core 共享 L3 缓存，分为多个 2M 的段，访问 L3 需要 38cycles，耗时大约 12ns；</li></ol></blockquote><p>缓存层级越接近于 CPU core，容量越小，速度越快，同时，其造价也更贵。所以为了支撑更多的热点数据，同时追求最高的性价比，多级缓存架构应运而生。</p><h3 id="3-cache-line-缓存行"><a href="#3-cache-line-缓存行" class="headerlink" title="#3 cache line 缓存行"></a>#3 cache line 缓存行</h3><p>CPU Cache 是由多个Cache Line缓存行组成的，Cache Line可以简单的理解为CPU Cache中的最小缓存单位。目前主流的CPU Cache的Cache Line大小都是64Bytes。假设我们有一个512字节的一级缓存，那么按照64B的缓存单位大小来算，这个一级缓存所能存放的缓存个数就是<code>512/64 = 8</code>个。</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/多级缓存.png" alt="img"></p><h3 id="4-CPU-访问缓存、内存"><a href="#4-CPU-访问缓存、内存" class="headerlink" title="#4 CPU 访问缓存、内存"></a>#4 CPU 访问缓存、内存</h3><p>​    试想一下你正在遍历一个长度为 16 的 long 数组 data[16]，原始数据自然存在于主内存中，访问过程描述如下</p><ol><li>访问 data[0]，CPU core 尝试访问 CPU Cache，未命中。</li><li>尝试访问主内存，操作系统一次访问的单位是一个 Cache Line 的大小 — 64 字节，这意味着：既从主内存中获取到了 data[0] 的值，同时将 data[0] ~ data[7] 加入到了 CPU Cache 之中，for free~</li><li>访问 data[1]~data[7]，CPU core 尝试访问 CPU Cache，命中直接返回。</li><li>访问 data[8]，CPU core 尝试访问 CPU Cache，未命中。</li><li>尝试访问主内存。重复步骤 2</li></ol><p>当CPU执行运算的时候，它先去L1查找所需的数据、再去L2、然后是L3，如果最后这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要尽量确保数据在L1缓存中。</p><p>另外，线程之间共享一份数据的时候，需要一个线程把数据写回主存，而另一个线程访问主存中相应的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">1024</span> * <span class="number">1024</span>][<span class="number">8</span>];</span><br><span class="line">        <span class="comment">// 横向遍历</span></span><br><span class="line">        <span class="keyword">long</span> marked = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                sum += arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Loop times:"</span> + (System.currentTimeMillis() - marked) + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">        marked = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 纵向遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1024</span> * <span class="number">1024</span>; j++) &#123;</span><br><span class="line">                sum += arr[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Loop times:"</span> + (System.currentTimeMillis() - marked) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过上面这段代码对一个二维数组进行纵向和横向的遍历，最后输出结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Loop times:<span class="number">19</span>ms</span><br><span class="line">Loop times:<span class="number">48</span>ms</span><br></pre></td></tr></table></figure><p>当使用纵向遍历时，每次遍历都需要从内存里重新读取数据，之前读取的只能作废，多次访问内存导致耗时更长。</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>从CPU到</strong></th><th><strong>大约需要的CPU周期</strong></th><th><strong>大约需要的时间</strong></th></tr></thead><tbody><tr><td style="text-align:left">主存</td><td>-</td><td>约60-80ns</td></tr><tr><td style="text-align:left">QPI 总线传输(between sockets, not drawn)</td><td>-</td><td>约20ns</td></tr><tr><td style="text-align:left">L3 cache</td><td>约40-45 cycles</td><td>约15ns</td></tr><tr><td style="text-align:left">L2 cache</td><td>约10 cycles</td><td>约3ns</td></tr><tr><td style="text-align:left">L1 cache</td><td>约3-4 cycles</td><td>约1ns</td></tr><tr><td style="text-align:left">寄存器</td><td>1 cycle</td><td>-</td></tr></tbody></table></div><h3 id="4-伪共享"><a href="#4-伪共享" class="headerlink" title="#4 伪共享"></a>#4 伪共享</h3><p>如同提到CAS就无法避免提到ABA问题一样，伪共享问题也是CPU缓存行相关的一定会提及的问题。</p><p>伪共享指的是多个线程同时读写同一个缓存行的不同变量时导致的 CPU 缓存失效。因为这些变量位于主存中邻近的位置，所以他们存在于一个缓存行中，当对缓存行的某个数据进行操作，就会导致整个缓存行失效，导致如果需要读取本应在此缓存行中的数据需要从主存中重新读区。这样，在频繁的多线程操作下，CPU 缓存将会彻底失效，降级为 CPU core 和主内存的直接交互。</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/伪共享.png" alt="img"  /></p><p>伪共享问题的解决方式就是<strong>字节填充</strong></p><p>字节填充的宗旨就是不同线程的变量存在不同的缓存行上，这样多个线程的操作就不会造成彼此的缓存行失效，使用多余的字节填充就可以实现这一点。</p><p>字节填充可以用<strong>Padding方式</strong>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为了避免 JVM 的自动优化，需要使用继承的方式来填充</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPaddingObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6;<span class="comment">// 填充</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingObject</span> <span class="keyword">extends</span> <span class="title">AbstractPaddingObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;    <span class="comment">// 实际数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际数据 value + 用于填充的 p1~p6 总共只占据了 7 <em> 8 = 56 个字节，而 Cache Line 的大小应当是 64 字节，这是有意而为之，在 Java 中，<em>* 对象头还占据了 8 个字节 </em></em>，所以一个 PaddingObject 对象可以恰好占据一个 Cache Line。</p><p>Java8中提供了<strong>官方的字节填充注释</strong>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sun.misc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Contended &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">注意需要同时开启 JVM 参数：</span></span><br><span class="line"><span class="comment">-XX:-RestrictContended=false</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><blockquote><p>@Contended 注解会增加目标实例大小，来使各个变量在Cache line中分隔开,要谨慎使用。默认情况下，除了 JDK 内部的类，JVM 会忽略该注解。要应用代码支持的话，要设置 -XX:-RestrictContended=false，它默认为 true（意味仅限 JDK 内部的类使用）。当然，也有个 –XX: EnableContented 的配置参数，来控制开启和关闭该注解的功能，默认是 true，如果改为 false，可以减少 Thread 和 ConcurrentHashMap 类的大小。参见《Java 性能权威指南》210 页。</p></blockquote><p>Java中很多地方都用到了这个注解，比如 <code>ConcurrentHashMap</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Counter support -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A padded cell for distributing counts.  Adapted from LongAdder</span></span><br><span class="line"><span class="comment"> * and Striped64.  See their internal docs for explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    CounterCell(<span class="keyword">long</span> x) &#123;value = x;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Thread</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The following three initially uninitialized fields are exclusively</span></span><br><span class="line"><span class="comment">// managed by class java.util.concurrent.ThreadLocalRandom. These</span></span><br><span class="line"><span class="comment">// fields are used to build the high-performance PRNGs in the</span></span><br><span class="line"><span class="comment">// concurrent code, and we can not risk accidental false sharing.</span></span><br><span class="line"><span class="comment">// Hence, the fields are isolated with @Contended.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The current seed for a ThreadLocalRandom */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</span><br><span class="line"><span class="keyword">long</span> threadLocalRandomSeed;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Probe hash value; nonzero if threadLocalRandomSeed initialized */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</span><br><span class="line"><span class="keyword">int</span> threadLocalRandomProbe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Secondary seed isolated from public ThreadLocalRandom sequence */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</span><br><span class="line"><span class="keyword">int</span> threadLocalRandomSecondarySeed;</span><br></pre></td></tr></table></figure><h2 id="三、加锁与CAS"><a href="#三、加锁与CAS" class="headerlink" title="三、加锁与CAS"></a>三、加锁与CAS</h2><h3 id="Java内置队列"><a href="#Java内置队列" class="headerlink" title="#Java内置队列"></a>#Java内置队列</h3><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20210529033830072.png" alt="image-20210529033830072"></p><p>在学习Disruptor之前，先看下Java内置的线程安全队列存在的问题：</p><p>​    队列的实现方式一般是三种：数组、链表、堆，其中堆实现是为了实现带优先级的队列；这里就只专注于数组和链表实现的队列：</p><p>​    基于数组线程安全的队列，典型的是ArrayBlockingQueue，它主要通过加锁的方式来保证线程安全；</p><p>​    基于链表的线程安全队列分成LinkedBlockingQueue和ConcurrentLinkedQueue两大类，前者也通过锁的方式来实现线程安全，而后者以及上面表格中的LinkedTransferQueue都是通过原子变量CAS无锁的方式来实现的。</p><blockquote><p><strong>有界性</strong>：是否保证队列的长度在确定的范围内 。</p></blockquote><p>​     不加锁实现的队列都是无界的，加锁实现的队列都是有界的，为了追求稳定性，防止生产者速度过快，导致内存溢出，只能选择有界队列；同时，为了减少Java的垃圾回收对系统性能的影响，会尽量选择array/heap格式的数据结构。这样筛选下来，符合条件的队列就只有ArrayBlockingQueue。</p><p>Disrupor的论文中进行了一次实验，64位的计数器循环自增5亿次，使用不同的实现方式的耗时情况如下：</p><div class="table-container"><table><thead><tr><th>Method</th><th>Time (ms)</th></tr></thead><tbody><tr><td>Single thread</td><td>300</td></tr><tr><td>Single thread with CAS</td><td>5,700</td></tr><tr><td>Single thread with lock</td><td>10,000</td></tr><tr><td>Single thread with volatile write</td><td>4,700</td></tr><tr><td>Two threads with CAS</td><td>30,000</td></tr><tr><td>Two threads with lock</td><td>224,000</td></tr></tbody></table></div><p>单线程情况下，无锁性能 &gt; CAS的性能 &gt; 加锁的性能</p><p>多线程情况下为了保证线程安全，必须要使用CAS或者锁，因此CAS的性能要优于加锁的性能，大约是8倍的差别。</p><h3 id="锁"><a href="#锁" class="headerlink" title="#锁"></a>#锁</h3><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/9b6a41f7d8527df9730b7832b38ec4d5180025.png" alt="图1 通过加锁的方式实现线程安全" style="zoom:50%;" /></p><p>  加锁的方式中访问数据需要先加锁再访问，访问后解锁。保证同时只有一个线程访问。</p><h3 id="原子变量"><a href="#原子变量" class="headerlink" title="#原子变量"></a>#原子变量</h3><p>​    原子变量能够保证原子性的操作，在某个任务的执行过程中，要么全部成功，要么全部失败回滚。</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/de0ced42337014947e7466db4d8f2d4d158395.png" alt="图2 通过原子变量CAS实现线程安全"></p><p>如图，CAS操作回将现在的value和当初读出的值进行比较，若相同则赋值；若不同则执行失败。</p><h2 id="四、Disruptor"><a href="#四、Disruptor" class="headerlink" title="四、Disruptor"></a>四、Disruptor</h2><h3 id="背景"><a href="#背景" class="headerlink" title="#背景"></a>#背景</h3><p>​    Disruptor是英国外汇交易公司LMAX开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与I/O操作处于同样的数量级）。基于Disruptor开发的系统单线程能支撑每秒600万订单，2010年在QCon演讲后，获得了业界关注。2011年，企业应用软件专家Martin Fowler专门撰写长文介绍。同年它还获得了Oracle官方的Duke大奖。</p><h3 id="Disruptor的解决方案"><a href="#Disruptor的解决方案" class="headerlink" title="#Disruptor的解决方案"></a>#Disruptor的解决方案</h3><ul><li><strong>环形数组</strong>：避免垃圾回收，使用数组而不是链表，而且对缓存机制更加友好；</li><li><strong>元素位置定位</strong>：数组长度2^n，通过位运算快速定位，index是long类型，即便是100万qps，也需要30万年才能用完；</li><li><strong>无锁设计</strong>：每个生产者或消费者线程，会先申请可操作元素在数组中的位置，申请到之后才会在该位置写入或者读取数据。</li></ul><h3 id="无锁设计实现生产与消费"><a href="#无锁设计实现生产与消费" class="headerlink" title="#无锁设计实现生产与消费"></a>#无锁设计实现生产与消费</h3><h4 id="单个生产者"><a href="#单个生产者" class="headerlink" title="单个生产者"></a>单个生产者</h4><p>单线程生产者写入数据，这种情况比较简单：</p><ol><li>申请写入m个元素；</li><li>若有m个元素可以写入，则返回最大的序号，这里会判断一下是否会覆盖未消费的元素；</li><li>如果返回正确的最大序号，那么生产者就开始写入元素；</li></ol><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/e71c1449273361ec413fffc7b0bf5507208689.png" alt="图5 单个生产者生产过程示意图" style="zoom:50%;" /></p><h4 id="多个生产者"><a href="#多个生产者" class="headerlink" title="多个生产者"></a>多个生产者</h4><p>多个生产者的情况下，“如何防止多个线程重复写入同一元素”，Disruptor为了解决这个问题，让每个线程获取不通的一段数组空间来进行操作，这个只需要通过CAS就可以轻松做到。</p><p>但是在消费者消费时，可能消费到还未写入的元素，于是Disruptor引入了一个和RingBuffer大小相同的buffer：available Buffer。当某个位置写入成功的时候，便需要把available buffer对应的位置置位，在消费的时候会先确定available buffer中对应的位置是否是已经置位的状态，来判断是否已经可以进行消费。</p><p><strong>写数据</strong></p><ol><li>申请写入m个元素；</li><li>若是有m个元素可以写入，则返回最大的序列号。每个生产者会被分配一段独享的空间；</li><li>生产者写入元素，写入元素的同时设置available Buffer里面相应的位置，以标记自己哪些位置是已经写入成功的。</li></ol><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/5e06841b1bba4dcf1d3fac169734ba36133983.png" alt="图7 多个生产者情况下，生产者生产过程示意图" style="zoom:50%;" /></p><p><strong>读数据</strong></p><ol><li>申请读取到序号n；</li><li>若writer cursor &gt;= n，这时仍然无法确定连续可读的最大下标。从reader cursor开始读取available Buffer，一直查到第一个不可用的元素，然后返回最大连续可读元素的位置；</li><li>消费者读取元素。</li></ol><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/99c603494ea90c9535e165579daf340a161527.png" alt="图6 多个生产者情况下，消费者消费过程示意图" style="zoom:50%;" /></p><h3 id="Disruptor的使用Demo"><a href="#Disruptor的使用Demo" class="headerlink" title="#Disruptor的使用Demo"></a>#Disruptor的使用Demo</h3><h4 id="事件类"><a href="#事件类" class="headerlink" title="事件类"></a>事件类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lcl.disruptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuchanglin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: TestEvent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 事件类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/28 15:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者类"><a href="#生产者类" class="headerlink" title="生产者类"></a>生产者类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lcl.disruptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.RingBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuchanglin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: TestEventProducer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 生产者类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/28 15:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEventProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;TestEvent&gt; ringBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestEventProducer</span><span class="params">(RingBuffer&lt;TestEvent&gt; ringBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ringBuffer = ringBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onData</span><span class="params">(String orderId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sequence = ringBuffer.next();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TestEvent testEvent = ringBuffer.get(sequence);</span><br><span class="line">            testEvent.setId(orderId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ringBuffer.publish(sequence);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者类"><a href="#消费者类" class="headerlink" title="消费者类"></a>消费者类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lcl.disruptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.EventHandler;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.WorkHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuchanglin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: TestEventHandler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消费者类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/28 16:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">TestEvent</span>&gt;, <span class="title">WorkHandler</span>&lt;<span class="title">TestEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(TestEvent testEvent, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"threadName: "</span> + Thread.currentThread().getName() + <span class="string">", event: "</span> + testEvent + <span class="string">", sequence: "</span> + sequence + <span class="string">", endOfBatch: "</span> + endOfBatch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(TestEvent testEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"threadName: "</span> + Thread.currentThread().getName() + <span class="string">", event: "</span> + testEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lcl.disruptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.RingBuffer;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.YieldingWaitStrategy;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.dsl.Disruptor;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.dsl.ProducerType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuchanglin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: TestDisruptorDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: demo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/28 16:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDisruptorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Disruptor&lt;TestEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(</span><br><span class="line">                TestEvent::<span class="keyword">new</span>,</span><br><span class="line">                <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                ProducerType.SINGLE,</span><br><span class="line">                <span class="keyword">new</span> YieldingWaitStrategy() <span class="comment">//拒绝策略 自旋</span></span><br><span class="line">        );</span><br><span class="line"><span class="comment">//        disruptor.handleEventsWith(new TestEventHandler());</span></span><br><span class="line"><span class="comment">//        多消费者 重复消费</span></span><br><span class="line"><span class="comment">//        disruptor.handleEventsWith(new TestEventHandler(), new TestEventHandler());</span></span><br><span class="line"><span class="comment">//        多消费者 只消费一次</span></span><br><span class="line">        disruptor.handleEventsWithWorkerPool(<span class="keyword">new</span> TestEventHandler(), <span class="keyword">new</span> TestEventHandler());</span><br><span class="line">        disruptor.start();</span><br><span class="line">        RingBuffer&lt;TestEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line">        TestEventProducer eventProducer = <span class="keyword">new</span> TestEventProducer(ringBuffer);</span><br><span class="line"><span class="comment">//        eventProducer.onData(UUID.randomUUID().toString());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        多个生产者</span></span><br><span class="line">        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            fixedThreadPool.execute(() -&gt; eventProducer.onData(UUID.randomUUID().toString()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、Disruptor-源码分析"><a href="#五、Disruptor-源码分析" class="headerlink" title="五、Disruptor 源码分析"></a>五、Disruptor 源码分析</h3><h4 id="核心设计"><a href="#核心设计" class="headerlink" title="#核心设计"></a>#核心设计</h4><ul><li><strong>Event</strong> <em>在Disruptor框架中，事件是通过系统流动的数据单元。生产者创建事件，然后通过RingBuffer发布事件，消费者则从RingBuffer中获取事件并处理</em>  </li><li><strong>EventFactory</strong> <em>这是用于创建事件对象的工厂。由于Disruptor使用预分配的事件缓冲区（即RingBuffer），因此需要在启动时创建所有的事件对象。EventFactory就是用于创建这些事件对象的工厂接口。</em></li><li><strong>EventHandler</strong> <em>事件处理器是消费者的一部分，负责处理从RingBuffer中获取的事件。</em></li><li><strong>RingBuffer（环形缓冲区）</strong>：RingBuffer是Disruptor框架的核心。它是一个预分配的缓冲区，用于存储事件对象。生产者发布事件到RingBuffer，消费者则从RingBuffer中获取事件。</li><li><strong>Disruptor</strong>：这是框架的主类，用于配置和启动Disruptor系统。它包括生产者、消费者、RingBuffer以及事件处理逻辑等组成部分。</li></ul><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/e665f3a95e5c47568f36437fc2ea5340~tplv-k3u1fbpfcp-zoom-in-crop-mark-3024-0-0-0.image.png" alt="e665f3a95e5c47568f36437fc2ea5340~tplv-k3u1fbpfcp-zoom-in-crop-mark-3024-0-0-0.image"  /></p><h4 id="创建Disruptor"><a href="#创建Disruptor" class="headerlink" title="#创建Disruptor"></a>#创建Disruptor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Disruptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> EventFactory&lt;T&gt; eventFactory, //事件的构成器</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">int</span> ringBufferSize, // RingBuffer长度 容量</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ThreadFactory threadFactory, // 消费线程的创建工厂</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ProducerType producerType, // 单生产者模式或者多生产者模式 默认多生产者</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> WaitStrategy waitStrategy)</span> <span class="comment">// 等待策略 （RingBuffer中为空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(</span><br><span class="line">        RingBuffer.create(producerType, eventFactory, ringBufferSize, waitStrategy),</span><br><span class="line">        <span class="keyword">new</span> BasicExecutor(threadFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Disruptor</span><span class="params">(<span class="keyword">final</span> RingBuffer&lt;T&gt; ringBuffer, <span class="keyword">final</span> Executor executor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ringBuffer = ringBuffer;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    构造方法创建了<code>RingBuffer</code>和一个<code>Executor</code>，这两个组件构成了一个<code>Disruptor</code>。</p><p>​    <strong>RingBuffer</strong> 负责存储事件，申请Sequence和 publish event。</p><p>​    <strong>Excutor</strong> 负责运行消费逻辑</p><h4 id="创建RingBuffer"><a href="#创建RingBuffer" class="headerlink" title="#创建RingBuffer"></a>#创建RingBuffer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">RingBuffer&lt;E&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ProducerType producerType,</span></span></span><br><span class="line"><span class="function"><span class="params">    EventFactory&lt;E&gt; factory,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> bufferSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    WaitStrategy waitStrategy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (producerType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> SINGLE:</span><br><span class="line">            <span class="keyword">return</span> createSingleProducer(factory, bufferSize, waitStrategy);</span><br><span class="line">        <span class="keyword">case</span> MULTI:</span><br><span class="line">            <span class="keyword">return</span> createMultiProducer(factory, bufferSize, waitStrategy);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(producerType.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    根据生产者类型的不同（单生产者 or 多生产者）存在两种不同类型的RingBuffer。</p><p><strong>单生产者类型RingBuffer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class RingBuffer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">RingBuffer&lt;E&gt; <span class="title">createSingleProducer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    EventFactory&lt;E&gt; factory,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> bufferSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    WaitStrategy waitStrategy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SingleProducerSequencer sequencer = <span class="keyword">new</span> SingleProducerSequencer(bufferSize, waitStrategy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RingBuffer&lt;E&gt;(factory, sequencer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    RingBuffer的创建需要两个组件，一个SingleProducerSequencer和一个EventFactory。</p><p><strong>RingBuffer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class RingBuffer</span></span><br><span class="line">RingBuffer(</span><br><span class="line">    EventFactory&lt;E&gt; eventFactory,</span><br><span class="line">    Sequencer sequencer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">super</span>(eventFactory, sequencer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class RingBufferFields</span></span><br><span class="line">RingBufferFields(</span><br><span class="line">    EventFactory&lt;E&gt; eventFactory,</span><br><span class="line">    Sequencer sequencer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// sequence申请、维护以及发布</span></span><br><span class="line">    <span class="keyword">this</span>.sequencer = sequencer;</span><br><span class="line">    <span class="keyword">this</span>.bufferSize = sequencer.getBufferSize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferSize &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"bufferSize must not be less than 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Integer.bitCount(bufferSize) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"bufferSize must be a power of 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// indexMask主要是为了使用位运算取模的</span></span><br><span class="line">    <span class="keyword">this</span>.indexMask = bufferSize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 可以看到这个数组除了正常的size之外还有填充的元素，这个是为了解决false sharing的，本篇文章暂不展开</span></span><br><span class="line">    <span class="keyword">this</span>.entries = <span class="keyword">new</span> Object[sequencer.getBufferSize() + <span class="number">2</span> * BUFFER_PAD];</span><br><span class="line">    <span class="comment">// 预先填充数组元素，这对垃圾回收很优化，后续发布事件等操作都不需要创建对象，而只需要即可</span></span><br><span class="line">    fill(eventFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class RingBufferFields</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(EventFactory&lt;E&gt; eventFactory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bufferSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        entries[BUFFER_PAD + i] = eventFactory.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BUFFER_PAD 是一个常量 128 / scale 表示 ，创建数组时填充的数组空间个数，在64位jvm中大概是16个空间，为两倍的缓存行大小，避免了数组的开头和结尾在同一个缓存行而导致并发中的伪共享问题。</p><p><strong>BasicExecutor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicExecutor</span><span class="params">(ThreadFactory factory)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BasicExecutor的创建直接使用了<code>java.util.concurrent.Executor</code>接口实现，通过单参数<code>ThreadFactory</code>构造。</p><h4 id="事件处理逻辑注册-handleEventsWith"><a href="#事件处理逻辑注册-handleEventsWith" class="headerlink" title="#事件处理逻辑注册 handleEventsWith"></a>#事件处理逻辑注册 handleEventsWith</h4><p>​    在上面的<code>TestDisruptorDemo</code>中，将Disruptor创建完成后，需要通过调用<code>handleEventsWith</code>相关方法完成事件处理逻辑的注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disruptor.handleEventsWith(<span class="keyword">new</span> TestEventHandler());</span><br></pre></td></tr></table></figure><p>​    而方法的源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EventHandlerGroup&lt;T&gt; <span class="title">handleEventsWith</span><span class="params">(<span class="keyword">final</span> EventHandler&lt;? <span class="keyword">super</span> T&gt;... handlers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 第一个参数为一个空数组</span></span><br><span class="line">    <span class="keyword">return</span> createEventProcessors(<span class="keyword">new</span> Sequence[<span class="number">0</span>], handlers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> DataStructure </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Computer Science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>workReview:新服务的创建&amp;部署&amp;开发</title>
      <link href="/2021/02/15/workReview-%E6%96%B0%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA-%E9%83%A8%E7%BD%B2-%E5%BC%80%E5%8F%91/"/>
      <url>/2021/02/15/workReview-%E6%96%B0%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA-%E9%83%A8%E7%BD%B2-%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="零、写在前面"><a href="#零、写在前面" class="headerlink" title="零、写在前面"></a>零、写在前面</h2><p>​    现在是2021年的2月份了，思绪回到两个月之前，2020年圣诞节前，老大安排任务——迁移老项目中的邮件下发相关业务至一个mail的新服务中。虽然当时刚刚听到这个任务，觉得无非是接口代码的迁移，但是上手之后发现这个任务包括了服务的新建、部署、以及乱七八糟的配置，还有代码设计上需要做的优化。</p><p>​    两个月以来，接口迁移和两个版本的迭代需求与其他乱七八糟的事情并行进行，而且这两个月公司一直是ab班模式进行工作。幸运的是mail迁移任务算是比较圆满的完成了。年后回厂就该考虑真正进行灰度上线相关事宜，希望接下来的上线、扩量等后续工作不要出现问题🙏。</p><h2 id="一、代码设计——拦截器模式"><a href="#一、代码设计——拦截器模式" class="headerlink" title="一、代码设计——拦截器模式"></a>一、代码设计——拦截器模式</h2><p>​    首先关于邮件下发这一个需求，需要在设计上满足几个功能：</p><ul><li>邮箱域名、邮箱地址黑名单屏蔽</li><li>发送账号的路由</li><li>发送失败后切换从SendCloud发送转换为Aliyun发送</li></ul><p>​    为了保证这些功能彼此之间保持低耦合高内聚，便于之后的扩展，就需要一个比较好的设计模式来完成它（当然这里也是老大要求的），在圣诞节下班的路上，我首先联想到Netty源码中在一个pipeline中组装多个Handler的方式，来扩展Netty收发二进制流的操作，接着我又想到之前chat服务中的IM即时通讯中收发消息采用的拦截器模式，多个Filter组成一个FiltreChain的方式对Message进行过滤，最后经过与老大交流，老大一开始也是想让我采用FilterChain的方式来进行，算是正中下怀。</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20210215034400406.png" alt="image-20210215034400406"></p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20210215034622758.png" alt="image-20210215034622758">    </p><p>​    最终的Filter结构如上，创建了发送前调用的<code>beforeSend</code>方法和发送后调用的<code>afterSend</code>方法，以及一个FilterAdapter来对这两个接口添加默认实现，将三个实现类组装到FilterChain中去，发送邮件时进行链式的调用。</p><blockquote><p>即使是现在我仍然认为这样的设计存在很多的漏洞，发送的前置和后置参数应当选择什么？返回值应该是什么？</p><p>尽管如此我也明白，一个好的设计从来不是一蹴而就，是不断的修改、调整出来的。</p></blockquote><h2 id="二、多模块项目—模块之间的依赖关系"><a href="#二、多模块项目—模块之间的依赖关系" class="headerlink" title="二、多模块项目—模块之间的依赖关系"></a>二、多模块项目—模块之间的依赖关系</h2><p>​    一个简单的java项目通常只有一个模块，比如：</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20210215161108423.png" alt="image-20210215161108423"></p><p>​    但是，一般企业级的开发项目都会是存在多个模块，比如：</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20210215161158145.png" alt="image-20210215161158145"></p><p>​    mail项目就有<code>api-client</code>、<code>api-def</code>、<code>api-impl</code>、<code>server</code>这些模块，这些模块通过maven的父子依赖来组成依赖关系，子pom依赖父pom。</p><p>​    随着业务量的增长，单一模块的项目可能会存在这样的问题：</p><ul><li>不同业务之间的代码互相耦合，难以区分且快速定位问题</li><li>增加开发成本，入手难度增高</li><li>开发界线模糊，不易定位到具体负责人</li><li>对于有特殊需求的模块无法拆解，比如：上传 maven 仓库只需要部分代码即可，但由于只有 1 个模块，不得不全部上传。</li></ul><p>进行模块拆分，可以将这些问题改善、解决。</p><hr><p>到现在为止我还没有找到一个规范 ，具体该如何拆分这些模块，是按照业务去拆分，亦或者是按照代码的功能来拆分。我厂采用的拆分大体如下：</p><ul><li>Api-client 通常是dubbo接口暴露被引用为jar包的模块</li><li>Api-def 接口的定义、某些常量实体类等</li><li>Api-impl 接口的实现</li><li>Api-cache 缓存相关</li><li>Api-common 一些配置、常量、utils</li><li>consumer mq的消费者或者Listener</li><li>schedule 定时任务</li><li>Server web服务</li><li>Service-def Service层</li><li>Service-impl Service层的具体实现</li></ul><blockquote><p>模块之间的依赖关系 api模块只依赖最基础的三方模块，不能依赖其所在项目的模块，防止出现循环依赖</p><p>service模块需要依赖api模块 以及相应的common模块（基础的常用工具类或者result封装对象可以写在这里）和mapper模块（数据库的操作模块，也可以叫manager模块） 以及pojo模块（最基础的实体模块，其不应该再依赖任何模块），</p><p>common模块和mapper模块以及pojo模块， 在comsumer项目中有，通过install命令推到maven的本地仓库中</p><p>provider项目可以通过引入maven依赖的形式 去使用这些jar</p><p>启动类模块中需要依赖service模块，因为需要在启动的时候加载这些模块</p><p>🌚唯一一个从网上找到比较相关的规范</p></blockquote><h2 id="三、Dynamic-动态属性的应用"><a href="#三、Dynamic-动态属性的应用" class="headerlink" title="三、Dynamic 动态属性的应用"></a>三、Dynamic 动态属性的应用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; filterDomains = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;String, Boolean&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; filterAddress = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;String, Boolean&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DynamicStringProperty domains = DynamicPropertyFactory.getInstance()</span><br><span class="line">            .getStringProperty(DBDomainConfiguration.MAIL_BLACK_DOMAIN, <span class="string">""</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    refreshFilterDomainsSet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DynamicStringProperty address = DynamicPropertyFactory.getInstance()</span><br><span class="line">            .getStringProperty(DBDomainConfiguration.MAIL_BLACK_ADDRESS, <span class="string">""</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    refreshFilterAddressSet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">refreshAliyunDomainSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String confValue = aliyunWhiteDomains.get();</span><br><span class="line">        log.info(<span class="string">"refresh aliyunWhiteDomainSet ["</span> + confValue + <span class="string">"]"</span>);</span><br><span class="line">        String[] whiteDomains = StringUtils.split(confValue, <span class="string">','</span>);</span><br><span class="line">        aliyunDomains.clear();</span><br><span class="line">        <span class="keyword">if</span> (ArrayUtils.isNotEmpty(whiteDomains)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; whiteDomains.length; i++) &#123;</span><br><span class="line">                String whiteDomain = StringUtils.lowerCase(StringUtils.trimToNull(whiteDomains[i]));</span><br><span class="line">                <span class="keyword">if</span> (whiteDomain != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">"add aliyunWhiteDomain "</span> + whiteDomain);</span><br><span class="line">                    aliyunDomains.add(whiteDomain);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">refreshFilterDomainsSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value = domains.get();</span><br><span class="line">        log.info(<span class="string">"refresh filterDomains ["</span> + value + <span class="string">"]"</span>);</span><br><span class="line">        String[] filter = StringUtils.split(value, <span class="string">','</span>);</span><br><span class="line">        filterDomains.clear();</span><br><span class="line">        <span class="keyword">if</span> (ArrayUtils.isNotEmpty(filter)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : filter) &#123;</span><br><span class="line">                String blackDomain = StringUtils.lowerCase(StringUtils.trimToNull(s));</span><br><span class="line">                <span class="keyword">if</span> (blackDomain != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">"add filterDomains "</span> + blackDomain);</span><br><span class="line">                    filterDomains.add(blackDomain);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    这里我定义了两个Map来存放地址和域名的黑名单列表，每次发送前进行校验来判断是否命中，再决定是否继续发送。</p><p>​    邮件的域名和地址黑名单存放在mysql表格中，但是如果每次发送都要查一遍表进行校验，就显得很蠢，这个时候由Netflix推出的Archaius提供了这样的一个解决方案；Dynamic动态属性，如图中，我定义了两个<code>DynamicStringProperty</code>的成员变量<code>address</code>和<code>domains</code>,当我在项目运行时，将mysql数据库中的数据进行修改，这两个成员变量就会发生变化，<strong>保持与数据库中的数据一致</strong>。而这里可以定义一个回调方法，在成员变量发生变化时调用(我这里的回调时对存放地址和域名的黑名单进行refresh操作)。</p><p>​    附上一个<code>DynamicStringProperty</code>对读取MySql数据库的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhipin.mail.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Maps;</span><br><span class="line"><span class="keyword">import</span> com.netflix.config.PollResult;</span><br><span class="line"><span class="keyword">import</span> com.netflix.config.PolledConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> com.zhipin.mail.dao.EmailBlackAddressDAO;</span><br><span class="line"><span class="keyword">import</span> com.zhipin.mail.dao.EmailBlackDomainDAO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBDomainConfiguration</span> <span class="keyword">implements</span> <span class="title">PolledConfigurationSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_BLACK_DOMAIN = <span class="string">"email_black_domain"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_BLACK_ADDRESS = <span class="string">"email_black_address"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EmailBlackDomainDAO emailBlackDomainDAO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EmailBlackAddressDAO emailBlackAddressDAO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBDomainConfiguration</span><span class="params">(EmailBlackDomainDAO emailBlackDomainDAO, EmailBlackAddressDAO emailBlackAddressDAO)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.emailBlackDomainDAO = emailBlackDomainDAO;</span><br><span class="line">        <span class="keyword">this</span>.emailBlackAddressDAO = emailBlackAddressDAO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PollResult <span class="title">poll</span><span class="params">(<span class="keyword">boolean</span> initial, Object checkPoint)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = load();</span><br><span class="line">        <span class="keyword">return</span> PollResult.createFull(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; blackDomainList = emailBlackDomainDAO.getConfigDomains();</span><br><span class="line">        List&lt;String&gt; blackAddressList = emailBlackAddressDAO.getConfigAddress();</span><br><span class="line">        Map&lt;String, Object&gt; result = Maps.newHashMap();</span><br><span class="line">        String domains = String.join(<span class="string">","</span>, blackDomainList);</span><br><span class="line">        String address = String.join(<span class="string">","</span>, blackAddressList);</span><br><span class="line">        result.put(MAIL_BLACK_DOMAIN, domains);</span><br><span class="line">        result.put(MAIL_BLACK_ADDRESS, address);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    除了感知Mysql数据库中数据的变化来更新动态属性的方式之外，Archaius的动态属性还可以配置为启动项、properties配置等许多方式，这里就不多说了，之后有机会可以单独去研究。</p><h2 id="四、部署问题相关"><a href="#四、部署问题相关" class="headerlink" title="四、部署问题相关"></a>四、部署问题相关</h2><p>​    时间来到开发结束，部署至开发环境，这个过程里问题不大，主要是发生了两个问题。</p><p><strong>#1 run脚本问题</strong></p><p>​    这个问题很难讲，我仔细检查run脚本，并没有发现什么不合理的地方，经过查阅资料看到网上有人提到<strong>shell脚本在Linux环境和普通ide开发的环境下存在字符集不一致的情况</strong>。这里我采用的解决方式是，把run脚本复制，在vim编辑模式下粘贴一遍，神奇的奏效了，可能问题确实发生在这里吧。。。。</p><p><strong>#2 maven打包配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.zhipin.mail.MailBootstrap<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span> // Mailootstrap </span><br><span class="line">        <span class="tag">&lt;<span class="name">executable</span>&gt;</span>true<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;service.name&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    部署方式采用maven打包成jar包，然后上传到服务器上运行的方式，这里的maven配置之前mainClass书写错误，导致jar包在运行的情况下找不到启动的main入口。可以想到，<strong>maven打包SpringBoot后jar包的启动入口就在这个<code>mainClass</code>标签下的main方法上</strong>。</p><h2 id="五、非Spring容器中Compent自动装配失败问题"><a href="#五、非Spring容器中Compent自动装配失败问题" class="headerlink" title="五、非Spring容器中Compent自动装配失败问题"></a>五、非Spring容器中Compent自动装配失败问题</h2><p>​    这个问题有点类似之前写过的<code>Spring自动装配的一次踩坑经历</code>中提到的问题。</p><p>​    是这样，存在这样一个类<code>CheckAndRetryTask</code>这个类的主要作用是邮件发送后的检验相关逻辑，而我每次发送完邮件都会new一个task，将它丢到线程池中去处理，而这个经过new创建的类中有一个标注了<code>@Autowired</code>的成员变量。这样的方式这个成员变量无法通过自动装配的方式来赋值，所以每次都会有NullPointerException。</p><p>​    这里我采用的方式是将自动装配方式改成直接从Spring容器中获取，这样就不会存在空指针异常了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResumeManager resumeManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 修改为👇</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ResumeManager resumeManager = (ResumeManager) ApplicationContextUtils.getBean(<span class="string">"resumeManager"</span>);</span><br></pre></td></tr></table></figure><p>附上一个<code>ApplicationContextUtils</code>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextUtils</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        ApplicationContextUtils.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line">        object = ApplicationContextUtils.applicationContext.getBean(name);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        T object = <span class="keyword">null</span>;</span><br><span class="line">        object = ApplicationContextUtils.applicationContext.getBean(clazz);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> </span>&#123;</span><br><span class="line">        T object = <span class="keyword">null</span>;</span><br><span class="line">        object = ApplicationContextUtils.applicationContext.getBean(name, requiredType);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ApplicationContextUtils.applicationContext.containsBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] getAliases(String name) &#123;</span><br><span class="line">        String[] s = <span class="keyword">null</span>;</span><br><span class="line">        s = ApplicationContextUtils.applicationContext.getAliases(name);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、dubbo接口引用"><a href="#六、dubbo接口引用" class="headerlink" title="六、dubbo接口引用"></a>六、dubbo接口引用</h2><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20210215174500237.png" alt="image-20210215174500237"></p><p>​    dubbo接口引用是将引用的配置写在<code>api-client</code>模块下，然后服务上游调用方直接引用项目deploy好的jar包的这个client模块就可以了。</p><p>引用配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"mailRegistry"</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"$&#123;zk_registry&#125;"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">group</span>=<span class="string">"$&#123;mail.dubbo.registry.group:zp_dubbo/mail&#125;"</span> <span class="attr">file</span>=<span class="string">"dubbo-registry-mail-provider.file"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"resumeMailApi"</span> <span class="attr">interface</span>=<span class="string">"com.zhipin.mail.api.ResumeMailApi"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">registry</span>=<span class="string">"mailRegistry"</span>  <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">check</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="七、Jenkins新建任务"><a href="#七、Jenkins新建任务" class="headerlink" title="七、Jenkins新建任务"></a>七、Jenkins新建任务</h2><p>​        是第一次在Jenkins上新建任务，其实现在回头来看也都比较简单，具体大概也就是一些参数的配置，比如git地址、分支名称、服务名称，具体要留意的一部分应该是Post Steps这个部分，这里采用shell脚本的方式来对已经经过Jenkins打包好的项目进行上传到服务器，然后运行的操作。</p><p><strong>Command</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in $&#123;service[*]&#125;</span><br><span class="line">do</span><br><span class="line"> JAR_NAME=`find $WORKSPACE/ -name "$i.jar"|grep -v SNAPSHOT`</span><br><span class="line">  scp -P port  $JAR_NAME work@host:/data/$i</span><br><span class="line">  ssh -p port  work@host "cd /data/$i;svc -dk .;svc -u .;"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>​    这里的shell主要作用是，循环遍历上面配置过的需要进行部署的服务名称，然后找到对应已经打包好的jar包，将它通过scp的方式上传到服务器的对应目录中，然后连接对应服务器，通过daemontools的方式进行重启。</p><blockquote><p>这里其实有个问题，如果当前项目是第一次部署，那么他的run脚本以及打包后的文件中的其他内容都不会上传到服务器上，实际上只会单独上传一个jar包，而当我们没有run脚本时，项目就无法启动。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for i in $&#123;service[*]&#125;</span><br><span class="line">do</span><br><span class="line">JAR_NAME=`find $WORKSPACE/ -name "*$i*.zip"`</span><br><span class="line">ssh -p port work@host "cd /data/$i; svc -dk .; rm -rf lib *.zip"</span><br><span class="line">scp -P port $JAR_NAME work@host:/data/$i</span><br><span class="line">ssh -p port work@host "cd /data/$i; unzip -o *.zip -x run; svc -u .;"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>​    这个shell就正常多了，首先将服务器上的服务进程杀死，然后上传打包好的整个zip包，然后在服务器上解压、启动。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>​    零零碎碎的两个月，零零碎碎的一堆问题，这些问题现在看来简单，解决方式清晰明了，但是在当时都是耗费了我很多心思，解决后有很大收获的问题；其实除了上述的这些问题之外也有很多没有写进来的问题，比如：</p><ul><li>RateLimiter qps限制器</li><li>mqConsumer 配置相关</li><li>Spring bean的配置</li></ul><p>​    这些其他问题可能是我还没有解决的很完善，或者是采用了公司现成的解决方案，也有些是不值一提的问题，不管怎样这些问题都是很有价值的问题，至少对现在的我是这样….</p><p>​    <strong>以上！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> workReview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty Study(三):Netty-Demo(Echo服务器&amp;客户端)</title>
      <link href="/2020/12/17/Netty-Study-%E4%B8%89-Netty-Demo-Echo%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>/2020/12/17/Netty-Study-%E4%B8%89-Netty-Demo-Echo%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Netty服务器端"><a href="#一、Netty服务器端" class="headerlink" title="一、Netty服务器端"></a>一、Netty服务器端</h2><p>一个Netty服务器应该包含两个部分：</p><ul><li>ChannelHandler：实现服务器对客户端接收数据的处理，也就是业务逻辑；</li><li>BootStrap： 服务器的启动部分，将服务器绑定到要监听连接请求到端口上；</li></ul><h3 id="1-ChannelHandler"><a href="#1-ChannelHandler" class="headerlink" title="#1 ChannelHandler"></a>#1 ChannelHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable<span class="comment">//标示一个ChannelHandler可以被多个Channel共享</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">      <span class="comment">//控制台打印消息记录</span></span><br><span class="line">      <span class="comment">//将接收到的消息 写给发送者，而 不冲刷出站消息</span></span><br><span class="line">        System.out.println(<span class="string">"Server received: "</span> + in.toString(StandardCharsets.UTF_8));</span><br><span class="line">        ctx.write(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">//将未决消息冲刷到 远程节点，并且关 闭该 Channel</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">//捕获异常，关闭连接</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EchoServerHandler</code>实现了<code>ChannelHandlerAdapter</code>（Netty in action书中是选择实现的<code>ChannelInboundHandlerAdapter</code>， <strong>在Netty 5.0版本之后，为了精简handler类型继承关系</strong>，<code>ChannelInboundHandler</code>和<code>ChannelOutboundHandler</code>被合并成<code>ChannelHandler</code>。现在<code>ChannelHandler</code>中既有<strong>inbound handler函数</strong>也有<strong>outbound handler函数</strong>)，Handler实现的<code>ChannelHandlerAdapter</code>有很多可重写的方法，这些方法都挂勾到事件生命周期的恰当时间点上。</p><p>关于<strong>异常捕获</strong>，如果ChannelPipline上的所有ChannelHandler都没有重写<code>exceptionCaught()</code>方法，那么所接收的一场会被传递到ChannelPipline的尾端并被记录。</p><blockquote><ul><li>针对不同类型的事件来调用 ChannelHandler;</li><li>应用程序通过实现或者扩展 ChannelHandler 来挂钩到事件的生命周期，并且提供自定义的应用程序逻辑;</li><li>在架构上，ChannelHandler 有助于保持业务逻辑与网络处理代码的分离。这简化了开发过程，因为代码必须不断地演化以响应不断变化的需求。</li></ul></blockquote><h3 id="2-ServerBootStrap"><a href="#2-ServerBootStrap" class="headerlink" title="#2 ServerBootStrap"></a>#2 ServerBootStrap</h3><p>引导服务器的具体作用主要是：</p><ul><li>绑定到服务器将在其上监听并接受传入连接请求的端口;</li><li>配置 Channel，以将有关的入站消息通知给 Handler 实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">//设置绑定端口</span></span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">            System.err.println("Usage: " + EchoServer.class.getSimpleName() + " &lt;port&gt;");</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">new</span> EchoServer(port).start(); <span class="comment">//启动服务器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">// 创建EventLoop</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap(); <span class="comment">//创建BootStrap 引导</span></span><br><span class="line">            serverBootstrap.group(group)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>) //指定<span class="title">Nio</span>传输<span class="title">Channel</span></span></span><br><span class="line"><span class="class">                    .<span class="title">localAddress</span>(<span class="title">new</span> <span class="title">InetSocketAddress</span>(<span class="title">port</span>))// 指定<span class="title">socket</span>地址</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123; <span class="comment">//ChannelInitializer</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(serverHandler);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind().sync(); <span class="comment">//真正的绑定服务器</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();<span class="comment">//直到服务器channel关闭，才会退出当前线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully().sync(); <span class="comment">//关闭并释放所有资源</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Channel、EventLoop两者相互配合实现基本的套接字操作</strong>，这里通过<code>ServerBootstrap</code>引导将其整合起来，channel()方法指定了NIO传输Channel，接着绑定本地端口（<code>InetSocketAddress</code>）。</p><p>通过<code>ChannelInitializer</code>在新链接接受时，创建新的子Channel，之后ChannelInitializer再会把已经定义好的serverHandler添加到pipline里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture channelFuture = serverBootstrap.bind().sync(); <span class="comment">//真正的绑定服务器</span></span><br><span class="line">channelFuture.channel().closeFuture().sync();<span class="comment">//直到服务器channel关闭，才会退出当前线程</span></span><br></pre></td></tr></table></figure><p>上面的<strong>第一行代码是服务器去绑定指定好的端口，使用sync()阻塞当前线程，直到绑定操作完成</strong>。<strong>第二行代码是阻塞等待直到服务器的所有Channel关闭</strong>，这里也就是保证了绑定好了端口之后不会执行finally代码块里的方法，导致整个Netty服务器关闭。这样就可以监听关闭事件，然后进行shutdownGracefully优雅关闭。</p><h2 id="二、Netty客户端"><a href="#二、Netty客户端" class="headerlink" title="二、Netty客户端"></a>二、Netty客户端</h2><h3 id="1-ChannelHandler-1"><a href="#1-ChannelHandler-1" class="headerlink" title="#1 ChannelHandler"></a>#1 ChannelHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"Netty rocks!"</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">"Client received: "</span> + in.toString(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要重写了三个方法，第一个<code>channelActive()</code>方法，这个方法会在一个链接调用的时候调用，这里编码了一个字符串“Netty rocks”字符串的Buffer，将其写入服务器（writeAndFlush）；</p><p>然后重写了<code>channelRead()</code>方法。接收数据时回调用这个方法，但是这里的接收可能不是一次性接收的，服务器发出来的消息可能进行分块接收，即使是几个字节很少量的数据，这个方法也可能调用两次，作为一个面向流的协议，TCP保证数组会按照服务器发送它的顺序去接收它。</p><p>第三个方法就是<code>exceptionCaught()</code>，和服务器端的一样，记录Throwable，关闭channel。</p><h3 id="2-BootStrap"><a href="#2-BootStrap" class="headerlink" title="#2 BootStrap"></a>#2 BootStrap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">remoteAddress</span>(<span class="title">new</span> <span class="title">InetSocketAddress</span>(<span class="title">host</span>, <span class="title">port</span>))</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture future = bootstrap.connect().sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.err.println(</span><br><span class="line">                    <span class="string">"Usage: "</span> + EchoClient<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>() +</span></span><br><span class="line">                            "&lt;host&gt; &lt;post&gt;"</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String host = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">new</span> EchoClient(host, port).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端的引导，类比服务器大部分一致，需要区别的地方主要在于：</p><ul><li>服务端使用的引导和客户端使用的引导类分别是ServerBootstrap和Bootstrap；</li><li>虽然上面代码指定的Channel是和服务端一样的NIO传输，但是其实可以在客户端上使用其他类型的传输方式 </li></ul><p>构建、运行、服务端和客户端分别打印对应发出或者收到的语句。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty Study(二):Netty组件</title>
      <link href="/2020/12/17/Netty-Study-%E4%BA%8C-Netty%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/12/17/Netty-Study-%E4%BA%8C-Netty%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Netty的核心组件"><a href="#一、Netty的核心组件" class="headerlink" title="一、Netty的核心组件"></a>一、Netty的核心组件</h2><p><strong><em>Netty中主要的组件<code>Channel</code>,<code>EventLoop</code>,<code>CHannelFuture</code>,这几个类和在一起可以基本组成Netty的功能；</em></strong></p><ul><li>Channel：Socket</li><li>EventLoop：控制流、多线程处理、并发；</li><li>ChannelFuture：异步通知；</li></ul><h3 id="1-Channel"><a href="#1-Channel" class="headerlink" title="#1 Channel"></a>#1 Channel</h3><blockquote><p>Channel是Java NIO的一个基本构造</p><p>它代表一个到实体(如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O操作的程序组件)的开放连接，如读操作和写操作。</p></blockquote><p>Channel 接口是 Netty 对网络操作抽象类，包括 <code>bind()</code>、<code>connect()</code>、<code>read()</code>、<code>write()</code>等基本的IO操作。</p><p>除了上述基本的IO操作，还由比较常用的Channel接口实现类：<code>NioServerSocketChannel</code>（服务端）和<code>NioSocketChannel</code>（客户端），这两个 Channel 可以和 BIO 编程模型中的<code>ServerSocket</code>以及<code>Socket</code>两个概念对应上。Channel拥有很多已经预定义的、专门化实现的广泛接口类：<code>EmbeddedChannel</code>,<code>LocalServerChannel</code>,<code>NioDatagramChannel</code>,<code>NioSctpChannel</code>等；Netty 的 Channel 接口所提供的 API，大大地降低了直接使用 Socket 类的复杂性。</p><p>目前，可以把Channel看作是传入或者传出数据的载体。可以被打开或者关闭，连接或者断开连接。</p><p>​    </p><h3 id="2-EventLoop"><a href="#2-EventLoop" class="headerlink" title="#2 EventLoop"></a>#2 EventLoop</h3><p>Netty 基于事件驱动模型，使用不同的事件来通知我们状态的改变或者操作状态的改变。它定义了在整个连接的生命周期里当有事件发生的时候处理的核心抽象。Netty使用EventLoop处理IO操作，Netty使用Channel和EventLoop相互配合来进行IO操作；</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20201215144525371.png" alt="image-20201215144525371"></p><p>Channel、EventLoop、EventLoopGroup之间的关系包括：</p><ul><li>一个EventLoopGroup包含一个或者多个EventLoop；</li><li>一个EventLoop在它的生命周期内只和一个Thread进行绑定；</li><li>所有有EventLoop处理的IO事件都将在它专有的Thread上被处理；</li><li>一个Channel在它的生命周期内只注册于一个EventLoop；</li><li>一个EventLoop可能会被分配给一个或者多个Channel；</li></ul><p>在这种设计中，一个给定的Channel的IO操作都是有相同的Thread执行的，实际上消除了对于同步的需要。</p><h3 id="3-ChannelFuture接口"><a href="#3-ChannelFuture接口" class="headerlink" title="#3 ChannelFuture接口"></a>#3 ChannelFuture接口</h3><p>由于Netty中所有的IO操作都是一部的。因为一个操作可能不会立刻返回，但是我们需要一种用于之后某个时间确定其结果的方法。也就是需要应用到<strong>回调</strong>的思想，也就是Netty提供的<code>ChannelFuture</code>接口，其<code>addListener()</code>方法注册了一个<code>ChannelFutureListener</code>，用来得到某个操作完成时结果的通知。</p><blockquote><p>ChannelFuture可以理解为是一个Netty操作执行结果的占位符，他究竟什么时候被执行可能取决于很多因素，不可能被准确预测，但是它一定会被执行。此外，所有属于一个Channel的操作都会被保证其将以被调用的顺序被执行。</p></blockquote><h2 id="二、ChannelHandler、ChannelPipeline"><a href="#二、ChannelHandler、ChannelPipeline" class="headerlink" title="二、ChannelHandler、ChannelPipeline"></a>二、ChannelHandler、ChannelPipeline</h2><p><code>ChannelHandler</code>、<code>ChannelPipeline</code>主要负责管理数据流以及执行应用程序处理逻辑的组件。</p><h3 id="1-ChannelHandler接口"><a href="#1-ChannelHandler接口" class="headerlink" title="#1 ChannelHandler接口"></a>#1 ChannelHandler接口</h3><p>ChannelHandler接口充当了所有处理入站数据和出站数据的应用程序逻辑的容器。我们通常会实现这个接口来自定义对数据处理的逻辑，ChannelHandler的方法是由<strong>网络事件</strong>来触发的，一般来说ChannelHandler可以处理任何类型的动作，可以是连接、数据接收、异常、数据转换等。</p><p>一般我们在使用Netty开发的时候，会选择实现<code>ChannelInboundHandler</code>子接口（ <strong>一般不会直接使用该接口，而是使用一个Adapter类，ChannelInboundHandlerAdapter，该类做了接口的基本实现，一般都是通过继承该类</strong>）这个类型的ChannelHandler接受入站事件和数据，这些数据随后会被业务逻辑所处理，也就是说应用程序的业务逻辑应当驻留在一个或者多个<code>ChannelInboundHandler</code>接口中。</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20201215165519917.png" alt="image-20201215165519917"></p><h3 id="2-ChannelPipeline接口"><a href="#2-ChannelPipeline接口" class="headerlink" title="#2 ChannelPipeline接口"></a>#2 ChannelPipeline接口</h3><p>ChannelHandler多个的情况下，ChannelPipeline提供了ChannelHandler链的容器，并定义了用于在该链上传播入站和出站时间流的API，<strong>当 Channel 被创建时，它会被自动地分配到它专属的 ChannelPipeline。</strong></p><p>ChannelHandler安装到ChannelPipeline的过程：</p><ul><li>一个ChannelInitializer的实现被注册到了ServerBootstrap中；</li><li>当ChannelInitializer.initChannel()方法被调用时，ChannelInitializer将在ChannelPipeline中安装一组自定义的ChannelHandler；</li><li>ChannelInitializer将它自己从ChannelPipeline中移除；</li></ul><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20201215173023596.png" alt="image-20201215173023596"></p><p>在这个过程中，数据或者事件经流 ChannelPipeline，由 ChannelHandler 处理。在这个处理过程中，一个 ChannelHandler 接收数据后处理完成后交给下一个 ChannelHandler，或者什么都不做直接交给下一个 ChannelHandler。</p><blockquote><p>一个 Netty 应用程序中入站和出站数据流之间的区别。从一个客户端应用程序 的角度来看，如果事件的运动方向是从客户端到服务器端，那么我们称这些事件为出站的，反之 则称为入站的。</p></blockquote><h4 id="编码器、解码器"><a href="#编码器、解码器" class="headerlink" title="编码器、解码器"></a>编码器、解码器</h4><p>当使用Netty发送或者接受一个消息时，需要进行字节格式和另一种格式（可能是Java对象）之间的相互转换；也就是<code>解码</code>、<code>编码</code>的过程。而且Netty还为编码器和解码器提供了不同类型的抽象类，可能在数据传输的时候不采用字节格式，比如使用Google的<strong>Protocol Buffers</strong>，Netty已经为它预置了<code>ProtobufEncoder</code>和<code>ProtobufDecoder</code>。</p><blockquote><p>严格地说，其他的处理器也可以完成编码器和解码器的功能。但是，正如有用来简化 ChannelHandler 的创建的适配器类一样，所有由 Netty 提供的编码器/解码器适配器类都实现 了 ChannelOutboundHandler 或者 ChannelInboundHandler 接口。</p></blockquote><h3 id="3-ChannelHandler-amp-ChannelPipeline"><a href="#3-ChannelHandler-amp-ChannelPipeline" class="headerlink" title="#3 ChannelHandler&amp;ChannelPipeline"></a>#3 ChannelHandler&amp;ChannelPipeline</h3><p>ChannelHandler 是专为支持广泛的用途而设计的，可以将它看作是处理往来ChannelPipeline事件(包括数据)的任何代码的通用容器。</p><p>ChannelHandler主要工作就是让事件流经ChannelPipeline，ChannelHandler在应用程序初始化或者引导阶段被安装，负责接收事件、执行处理逻辑，然后传递给下一个ChannelHandler，它们的<strong>添加顺序决定了他们的执行顺序</strong>。其实ChannelPipeline也可以被视作ChannelHandler的编排顺序。</p><blockquote><p>出站和进站运动中，通过使用作为参数传递到每个方法的 <strong>ChannelHandlerContext</strong>，事件可以被传递给当前ChannelHandler 链中的下一个 ChannelHandler。</p><p>而且Netty可以区分 <strong>ChannelInboundHandler</strong> 实现和 ChannelOutboundHandler 实现，并确保数据只会在具有相同定向类型的两个 ChannelHandler 之间传递。</p></blockquote><h2 id="三、引导（BootStrap）"><a href="#三、引导（BootStrap）" class="headerlink" title="三、引导（BootStrap）"></a>三、引导（BootStrap）</h2><blockquote><p>“引导”这个词在之前的代码Demo里也反复看到，本来以为是一个抽象的词，没想到所谓引导就是Bootstrap直译。。。</p></blockquote><p>Netty 的引导类<strong>为应用程序的网络层配置提供了容器</strong>，这涉及<strong>将一个进程绑定到某个指定的端口</strong>，或者将一个进程连接到另一个运行在某个指定主机的指定端口上的进程。因此，有两种类型的引导:一种用于<strong>客户端(简单地称为 Bootstrap)</strong>，而另一种用于<strong>服务器(ServerBootstrap)</strong>。无论你的应用程序使用哪种协议或者处理哪种类型的数据， 唯一决定它使用哪种引导类的是它是作为一个客户端还是作为一个服务器。</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20201215212249192.png" alt="image-20201215212249192"></p><p>引导一个客户端需要一个EventLoop，但是引导一个服务器ServerBootstrap需要两个；这是因为服务器需要第一组只包含一个ServerChannel来表示<strong>服务器自身已经绑定到某个本地端口正在监听的socket</strong>；然后将第二组将<strong>包含所有已经创建的用来处理传入客户端链接的Channel</strong>。</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20201215213350743.png" alt="image-20201215213350743"></p><blockquote><p>与 ServerChannel 相关联的 EventLoopGroup 将分配一个负责为传入连接请求创建 Channel 的 EventLoop。一旦连接被接受，第二个 EventLoopGroup 就会给它的 Channel 分配一个 EventLoop。</p></blockquote><p><strong>以上！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty Study(一):基本知识</title>
      <link href="/2020/10/17/Netty-Study-%E4%B8%80-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/10/17/Netty-Study-%E4%B8%80-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="零、写在前面"><a href="#零、写在前面" class="headerlink" title="零、写在前面"></a>零、写在前面</h2><p>​    七月份入职之后到现在已经三个多月了，我也顺利转正了，这几个月也在公司学习了很多东西，每周的技术分享都有让我想学的知识出现，之后有把所有想学的东西写在笔记里（真他妈多😅）。面对这么多的知识一度十分焦虑，不知道从何学起，不过仔细想想，这些东西能在两三年内学到我理想的程度已经很不错了。</p><p>​    Netty相关已经看了很久了，七月底的时候就开始看《Netty实战》，但是公司越来越忙，导致书看了忘，忘了再看，一直停留在原地没有进展，这次准备把之前看的书总结一下，省的再回去看忘掉的知识，同时也要尽快把Netty学习提上日程。这也是为了后续手写RPC框架的计划作准备。</p><h2 id="一、常见IO线程模型"><a href="#一、常见IO线程模型" class="headerlink" title="一、常见IO线程模型"></a>一、常见IO线程模型</h2><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/77752ed5.jpg" alt="emma_1"></p><p>​    任何一个IO过程中，都包含两个步骤：第一个是等待，第二是拷贝。而在实际应用的场景中，等待消耗的时间远远高于拷贝的时间；举例来说，<code>读函数</code>，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。需要说明的是等待就绪的阻塞时不使用CPU资源的，是在“空等”；而真正的读写操作的阻塞是使用CPU的，这个过程很快，甚至可以理解成基本不耗时。</p><p>​    <strong>为了让IO更加高效，最核心的方法就是让等待的时间尽可能的变少。</strong></p><h3 id="1-阻塞IO"><a href="#1-阻塞IO" class="headerlink" title="#1 阻塞IO"></a>#1 阻塞IO</h3><p>​    在内核将数据准备好之前，系统调用会一直等待。所有的套接字（socke），默认都是阻塞方式，<strong>阻塞式是最常见的IO模型，属于同步IO模型。</strong></p><p>​    例子：A拿着一支鱼竿在河边钓鱼，并且一直在鱼竿前等，在等的时候不做其他的事情，十分专心。只有鱼上钩的时，才结束掉等的动作，把鱼钓上来。</p><p>​    <img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/v2-7ee1abb79d9c79b1378c3ede0528bfa4_r.jpg" alt="preview"></p><h3 id="2-非阻塞IO"><a href="#2-非阻塞IO" class="headerlink" title="#2 非阻塞IO"></a>#2 非阻塞IO</h3><p>​    如果内核没有将数据准备好，系统的调用仍然会直接返回，并且返回EWOULDBLOCK错误码，非阻塞IO往往需要程序员循环的方式反复尝试读写文件描述符，这个过程被称为论询。这对CPU来说是比较大的浪费，<strong>非阻塞IO也属于同步IO模型。</strong></p><p>​    例子： B也在河边钓鱼，但是B不想将自己的所有时间都花费在钓鱼上，在等鱼上钩这个时间段中，B在做其他的事情（刷牛客或者刷知乎），但B在做这些事情的时候，每隔一个固定的时间检查鱼是否上钩。一旦检查到有鱼上钩，就停下手中的事情，把鱼钓上来。</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/v2-7f84267dc58c969fedd5606c76bd5905_r.jpg" alt="preview"></p><h2 id="二、BIO、NIO、AIO"><a href="#二、BIO、NIO、AIO" class="headerlink" title="二、BIO、NIO、AIO"></a>二、BIO、NIO、AIO</h2><h3 id="1-BIO（Blocking-I-O）"><a href="#1-BIO（Blocking-I-O）" class="headerlink" title="#1 BIO（Blocking I/O）"></a>#1 BIO（Blocking I/O）</h3><p>​    早期的网络编程开发人员，需要花费大量的时间去学习复杂的C语言套接字(Socket)库，但是会经常在不同的操作系统上出现奇怪的问题。早期的Java提供了java.net包下的API，支持使用由本地系统套接字库提供的阻塞函数。也就是BIO。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个新的ServerSocket，用来监听指定端口上的连接请求</span></span><br><span class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(portNumber);</span><br><span class="line"><span class="comment">//对accept方法的调用将会被一直阻塞，直到一个链接的建立</span></span><br><span class="line">Socket clientSocket = serverSocket.accept(); </span><br><span class="line"><span class="comment">//</span></span><br><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">  <span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>); </span><br><span class="line">String request, response;</span><br><span class="line"><span class="keyword">while</span> ((request = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">//如果客户端发送了‘Done’ 推出循环</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">"Done"</span>.equals(request)) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//把客户端请求发送给服务器的handler方法</span></span><br><span class="line">  response = processRequest(request);</span><br><span class="line">out.println(response); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    采用BIO通信模型的服务端，通常会有一个独立的Acceptor线程负责监听客户端的链接。在while（true）循环中服务端会调用accept()方法等待接受客户端的链接方式监听请求，请求一旦接受到一个链接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接受其他客户端的链接请求，只能等待当前链接的客户端的操作执行完成，也就是说这段代码只能同时处理一个连接，不过可以<strong>通过多线程</strong>来支持多个客户端的链接。 </p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20201018154929638.png" alt="image-20201018154929638"></p><blockquote><p>​    让我们考虑一下这种方案的影响。第一，在任何时候都可能有大量的线程处于休眠状态，只是等待输 入或者输出数据就绪，这可能算是一种资源浪费。第二，需要为每个线程的调用栈都分配内存，其默认值大小区间为64KB 到1MB，具体取决于操作系统。第三，即使 Java 虚拟机(JVM)在物理上可以支持非常大数量的线程，但是远在到达该极限之前，上下文切换所带来的开销就会带来麻烦，例如，在达到10000个连接的时候。</p><p>​                                                                                                                                    ——《Netty in Action》</p></blockquote><h3 id="2-NIO（Non-Blocking-IO）"><a href="#2-NIO（Non-Blocking-IO）" class="headerlink" title="#2 NIO（Non-Blocking IO）"></a>#2 NIO（Non-Blocking IO）</h3><p>​    NIO是一种同步非阻塞的I/O模型，在Java 1.4中引入了NIO框架，对应Java.nio包，提供了Channel，Selector，Buffer等抽象。</p><p>​    NIO中的N可以理解为<strong>Non-blocking</strong>，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。NIO提供了与传统BIO模型中的Socket和ServerSocket相对应的<strong>SocketChannel</strong>和<strong>ServerSocketChannel</strong>两种不同套接字通道实现，阻塞模式使用就像传统的支持一样，比较简单，但是性能和可用性都不好，但是非阻塞正好与他相反，<strong>对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用NIO的非阻塞模式来开发。</strong></p><p><strong>选择器</strong></p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20201018165658369.png" alt="image-20201018165658369"></p><p>​    图中的这种非阻塞设计，消除了上边BIO的那些弊端，Selector是Java的NIO实现的关键。检查一个或者多个NIO Channel（通道）的状态是否处于可读、可写。它使用事件通知API以确定在一组非阻塞套接字中那些已经就绪可以进行IO相关的操作。</p><h3 id="3-AIO（Asynchronous-IO）"><a href="#3-AIO（Asynchronous-IO）" class="headerlink" title="#3 AIO（Asynchronous IO）"></a>#3 AIO（Asynchronous IO）</h3><p>​    AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是<strong>异步非阻塞的IO模型</strong>。异步 IO 是基于<strong>事件和回调机制</strong>实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p>​    AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。（除了 AIO 其他的 IO 类型都是同步的，这一点可以从底层IO线程模型解释。</p><h2 id="三、Netty"><a href="#三、Netty" class="headerlink" title="三、Netty"></a>三、Netty</h2><blockquote><p>​    我们已经从漫长的痛苦经历中学到:直接使用底层的API暴露了复杂性，并且引入了对往往供不应求的技能的关键性依赖 。这也就是，面向对象的基本概念:</p><p>​    <strong>用较简单的抽象隐藏底层实现的复杂性。</strong></p><p>​     <strong>Hide complexity behind abstractions.</strong></p></blockquote><p>​    在这样的原则的驱使下，为了在高负载下可靠和高效的处理和调度IO操作，Netty应运而生，Netty驾驭了高级API的能力，并将其隐藏在一个易于使用的API之后。</p><blockquote><p>Netty是你可以专注于自己真正感兴趣的——你的应用程序独一无二的价值。</p></blockquote><h3 id="1-异步与事件驱动"><a href="#1-异步与事件驱动" class="headerlink" title="#1 异步与事件驱动"></a>#1 异步与事件驱动</h3><p><strong>同步和异步：</strong></p><ul><li><strong>同步</strong>：同步就是发起一个调用之后，<strong>被调用者未处理完请求之前</strong>，调用不返回。</li><li><strong>异步</strong>：异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠时间，回调机制来通知调用者其返回结果。</li></ul><p>同步和异步最大的区别在于异步的话调用者不需要等待处理结果，被调用者会通过回调机制来通知调用者其返回结果。</p><p><strong>阻塞与非阻塞：</strong></p><ul><li><strong>阻塞</strong>：阻塞就是发起一个请求，<strong>调用者一直等待请求结果返回</strong>，也就是当前线程会被挂起，无法从事其他任务，只有当条件满足才能继续。</li><li><strong>非阻塞</strong>：非阻塞就是发起一个请求，<strong>调用者不用一直等着结果返回</strong>，可以去先干其他事情。</li></ul><blockquote><p>​    在日常的生活中，异步自然而然地就发生了，所以你可能没有对它考虑过多少。但是让一个 计算机程序以相同的方式工作就会产生一些非常特殊的问题。<strong>本质上，一个既是异步的又是事件驱动的系统会表现出一种特殊的、对我们来说极具价值的行为:它可以以任意的顺序响应在任意 的时间点产生的事件。</strong></p><p>​                                                                                                                                    ——《Netty in Action》</p></blockquote><hr><p>​    在直接看来，同步和阻塞，异步和非阻塞看起来描述的是一种情况，但是为什么还需要区分开来两类概念呢？这里我认为，<code>阻塞和非阻塞</code>，<code>异步和同步</code>其实是从两种维度来进行的描述。</p><p>​    同步和异步关注的是<strong>消息通信机制</strong> (synchronous communication/asynchronous communication)是在描述<strong>调用</strong>与<strong>返回结果</strong>两者的关系。</p><p>​    比如<strong>同步的机制下，调用就必须要有一个结果</strong>；没有结果，调用就不返回，也就是说<strong>调用者必须要主动等待这个调用的结果</strong>。</p><p>​    而异步则是相反，调用在发出之后，这个调用就直接返回了，当一个<strong>异步过程调用发出后，调用者不会立刻得到结果</strong>。而是在调用发出后，被调用者通过<strong>状态、通知来通知调用者，或通过回调函数处理这个调用。</strong></p><p>​    阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong></p><p>​    阻塞调用是指调用结果返回之前，当前<strong>线程会被挂起</strong>。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用<strong>不会阻塞当前线程</strong>。</p><h3 id="2-可伸缩性"><a href="#2-可伸缩性" class="headerlink" title="#2 可伸缩性"></a>#2 可伸缩性</h3><blockquote><p>一种系统、网络或者进程在需要处理的工作不断增长时，可以通过某种可行的方式或者扩大它的处理能力来适应这种增长的能力 。</p></blockquote><p>​    异步的能力对于实现更高的<strong>可伸缩性</strong>至关重要。</p><p>异步和可伸缩性之间的联系在于：</p><ul><li><p>非阻塞网络调用使得我们可以<strong>不必等待一个操作的完成</strong>。完全异步的 I/O 正是基于这个特性构建的，并且更进一步:<strong>异步方法会立即返回，并且在它完成时，会直接或者在稍后的某个时间点通知用户。</strong></p></li><li><p><strong>选择器</strong>使得我们能够通过较少的线程便可监视许多连接上的事件。</p></li></ul><p>​    将这些元素结合到一起，与使用阻塞IO来处理大量连接相比，使用非阻塞IO来处理会更快速、更经济。这也是Netty设计的关键。</p><h3 id="3-特性总结"><a href="#3-特性总结" class="headerlink" title="#3 特性总结"></a>#3 特性总结</h3><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20201025144215918.png" alt="image-20201025144215918"></p><p><strong>以上！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非对称加密——RSA算法</title>
      <link href="/2020/10/04/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E2%80%94%E2%80%94RSA%E7%AE%97%E6%B3%95/"/>
      <url>/2020/10/04/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E2%80%94%E2%80%94RSA%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、公钥密码学"><a href="#一、公钥密码学" class="headerlink" title="一、公钥密码学"></a>一、公钥密码学</h2><blockquote><p>在某些情况下，某个问题难以解决这样一个事实已经不再是一个缺点，而变成了一个优点。</p></blockquote><p>​    存在这样一个问题：为一个给定的整数找到它的因数，如果这样的解确实存在，那么就一定要为这个问题找到一个有效的解。如果只用纸和笔，那么即使像2173这样相对较小的数字，要找到其因数，也很花时间，假如数字大到几百位数字才能表示，那么即使是用现在最好的因数分解技术，这个问题也还是很难解决。</p><p>​    假如密码的破解也像解决这种复杂数学问题一样，那么这样的加密算法一定是一种安全的算法。</p><p><strong>一些历史</strong></p><p>​    1976年之前，所有的加密方式都是一种模式：</p><blockquote><p>（1）甲方选择某一种加密规则，对信息进行加密；</p><p>（2）乙方使用同一种规则，对信息进行解密。</p></blockquote><p>​    由于加密和解密使用的同一种规则（简称为”密钥”），这就被称为<strong>对称加密算法(Symmetric-key algorithm)</strong>。这种规则下必须要让甲乙方都知道加密规则才正常的使用这样的加密算法，所以这也导致这个算法最大的弱点就在于如何保存和传递密钥。</p><p>​    1976年，两位美国计算机科学家Whitfield Diffie和 Martin Hellman，提出一种崭新的构思，可以在在不直接传递密钥的情况下，完成解密。这被称为<strong>“Diffie-Hellman密钥交换算法”</strong>。这个算法让人们意识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种关系即可。</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/bg2013062703.jpg" alt="img"></p><p>​    这种新的模式被称为<strong>非对称加密算法</strong></p><blockquote><p>（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的</p><p>（2）甲方获取乙方的公钥，然后用它对信息加密。</p><p>（3）乙方得到加密后的信息，用私钥解密。</p></blockquote><p>​    1977年，三位数学家Ricest、Shamir和Adleman设计了一种算法，可以实现非对称加密，这种算法用他们三个人的名字命名，叫做RSA算法。</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/bg2013062702.jpg" alt="img"></p><p>​    <strong>只要有计算机网络的地方，就有RSA算法。</strong></p><h2 id="二、RSA算法的数学基础"><a href="#二、RSA算法的数学基础" class="headerlink" title="二、RSA算法的数学基础"></a>二、RSA算法的数学基础</h2><p>​    RSA算法的原理并不复杂，只需要一些数论的知识。</p><h3 id="互质关系"><a href="#互质关系" class="headerlink" title="#互质关系"></a>#互质关系</h3><p>​    如果两个正整数，除了1以外，没有其他公因子，那么我们就称这两个数是<strong>互质关系(coprime)</strong>。比如，15和32没有公因子，所以他们是互质关系。(不是质数也可以构成互质关系)</p><p>一些结论👇🏻：</p><blockquote><ol><li><p>任意两个质数构成互质关系，比如13和61。</p></li><li><p>一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。</p></li><li><p>如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。</p></li><li><p>1和任意一个自然数是都是互质关系，比如1和99。</p></li><li><p>p是大于1的整数，则p和p-1构成互质关系，比如57和56。</p></li><li><p>p是大于1的奇数，则p和p-2构成互质关系，比如17和15。</p></li></ol></blockquote><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="#欧拉函数"></a>#欧拉函数</h3><p>​    思考一个问题👇🏻：</p><blockquote><p>任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？</p></blockquote><p>​    计算这个值的方法就叫做欧拉函数，以φ(n)表示。比如，与8形成互质关系的数字有：1、3、5、7，</p><p>所以φ(n) = 4。</p><p>​    φ(n)的计算方法并不复杂，但是为了得到最后的公式，需要进行一步步的推导。</p><p><strong>第一种情况</strong></p><p>​    如果，n = 1，那么φ(1) = 1。因为1与任何数(包括自身)都形成互质关系。</p><p><strong>第二种情况</strong></p><p>​    如果n是质数，则φ(n) = n - 1。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。</p><p><strong>第三种情况</strong></p><p>​    如果n是质数的n次方，即n = p<sup>k</sup> (p为质数，k为大于等于1的整数)，那么φ(n)可以由公式计算</p><script type="math/tex; mode=display">φ(p^k) = p^k - p^{k-1}</script><p>​    比如 φ(8) = φ(2<sup>3</sup>) = 2<sup>3</sup> - 2<sup>2</sup> = 4</p><p>​    这个公式是因为当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有p<sup>(k-1)</sup>个，即1×p、2×p、3×p、…、p^(k-1)×p，把它们去除，剩下的就是与n互质的数。(<strong>质数与任何一个不是它倍数的数互质，参考互质关系结论2</strong>)</p><p>​    这个公式还可以化简成：</p><script type="math/tex; mode=display">φ(p^k) = p^k - p^{k-1} = p^k(1-\frac1p)</script><p><strong>第四种情况</strong></p><p>​    如果n可以分成两个互质的数的乘积，那么φ(n)满足这样的条件：</p><blockquote><p>n = p1 * p2</p><p>φ(n) = φ(p1p2) = φ(p1) * φ(p2)</p></blockquote><p>​    这个结论的证明要用到<strong>中国剩余定理</strong>，简单的思路就是：如果a与p1互质(a&lt;p1)，b与p2互质(b&lt;p2)，c与p1p2互质(c&lt;p1p2)，则c与数对 (a,b) 是一一对应关系。由于a的值有φ(p1)种可能，b的值有φ(p2)种可能，则数对 (a,b) 有φ(p1)φ(p2)种可能，而c的值有φ(p1p2)种可能，所以φ(p1p2)就等于φ(p1)φ(p2)。</p><p><strong>第五种情况</strong></p><p>​    <strong>每个大于1的自然数，要么本身就是质数，要么可以写为2个或以上的质数的积。（算数基本定理）</strong>那么根据上边的几种情况中的推论，可以得到一个欧拉函数的通用公式。</p><script type="math/tex; mode=display">n = p_1^{k_1} p_2^{k_2} p_3^{k_3}... p_r^{k_r}\\φ(n) = n(1 - \frac1p_1)(1 - \frac1p_2)(1 - \frac1p_3)...(1 - \frac1p_r)</script><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="#欧拉定理"></a>#欧拉定理</h3><p>​    欧拉定理就是欧拉函数的用处，欧拉定理指的是：</p><p>​    如果两个正整数a和n互质，则n的欧拉函数φ(n)可以让下面的等式成立</p><script type="math/tex; mode=display">a^{φ(n)} \equiv 1\pmod n</script><p>​    a的φ(n)次方被n除的余数为1。也就是说，a的φ(n)次方减1，可以被n整除。比如，3和7互质，那么7的欧拉函数φ(7)等于6，3的6次方（729）减去1可以被7整除（728/7 = 104）。</p><p>​    欧拉定理还有一个特殊情况，假设正整数a和质数p互质，因为质数p的φ(p)等于p-1，那么欧拉定理可以写成：</p><script type="math/tex; mode=display">a^{p-1}\equiv 1 \pmod p</script><p>这就是很著名的<strong>费马小定理</strong>，是欧拉定理的特例。欧拉定理是RSA算法的核心。</p><h3 id="模运算基本性质"><a href="#模运算基本性质" class="headerlink" title="#模运算基本性质"></a>#模运算基本性质</h3><p>(a + b) % p = (a % p + b % p) % p</p><p>(a - b) % p = (a % p - b % p) % p</p><p>(a <em> b) % p = (a % p </em> b % p) % p</p><p>(a^b) % p = ((a % p)^b) % p</p><h3 id="模反元素"><a href="#模反元素" class="headerlink" title="#模反元素"></a>#模反元素</h3><blockquote><p>如果两个正整数a和n互质，那么一定可以找到一个整数b，使得ab - 1被n整除，或者说ab被n整除得余数是1。</p></blockquote><script type="math/tex; mode=display">ab \equiv 1 \pmod n</script><p>​    这里，b就被称为a的“<strong>模反元素</strong>”，比如，3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。显然，模反元素不止一个， 4加减11的整数倍都是3的模反元素 {…,-18,-7,4,15,26,…}，即如果b是a的模反元素，则 b+kn 都是a的模反元素。</p><p>​    可以使用欧拉定理来证明模反元素必定存在👇🏻：</p><script type="math/tex; mode=display">a^{φ(n)} = a \times a^{φ(n)-1}  \equiv 1\pmod n</script><p>​    这里的a的φ(n)-1次方就是a的模反元素。</p><p>至此，RSA所涉及到的所有数学知识就是上面这些了。</p><h2 id="三、RSA算法的加密流程"><a href="#三、RSA算法的加密流程" class="headerlink" title="三、RSA算法的加密流程"></a>三、RSA算法的加密流程</h2><h3 id="密钥的生成"><a href="#密钥的生成" class="headerlink" title="#密钥的生成"></a>#密钥的生成</h3><p>​    密钥，也就是通信双方使用的公钥和私钥的生成需要先通过数学方式计算出几个值。</p><p><strong>第一步，选择两个质数</strong></p><p>​    随机选取两个<strong>不相等</strong>的质数p和q，假设我们这里选择了61和53。（在RSA实际使用中，往往会选择比较大的质数，质数越大，就越难破解）</p><blockquote><p>p = 61</p><p>q = 53</p></blockquote><p><strong>第二步，计算两个质数的积</strong></p><p>​    计算p和q的乘积为n</p><blockquote><p>n = p <em> q = 61 </em> 53 = 3233</p></blockquote><p>​    n的长度就是密钥的长度，3233写成二进制是<code>110010100001</code>,一共是12位，所以密钥的长度就是12位。在实际应用中，往往选择1024位甚至是2048位的密钥。</p><p><strong>第三步，求欧拉函数φ(n)</strong></p><p>​    根据公式(欧拉函数情况二)：</p><script type="math/tex; mode=display">φ(n) = (p-1)(q-1)</script><p>​    也就是这里可以计算出φ(n)：</p><blockquote><p>φ(n) = (p-1)(q-1) =&gt; φ(3233) = 60 * 52 = 3120</p></blockquote><p><strong>第四步，随机选择一个与φ(n)互质的整数e</strong></p><p>​    选择一个与φ(n)互质，而且满足 1 &lt; e &lt; φ(n)条件的整数e，这里我们选择17（在RSA实际应用中，我们往往选择65537）</p><blockquote><p>e = 17</p></blockquote><p><strong>第五步，计算模反元素</strong></p><p>​    计算e对于φ(n)的模反元素d。</p><p>​    根据公式：</p><script type="math/tex; mode=display">ab \equiv 1 \pmod n \\ 即 \\ ed \equiv 1 \pmod {φ(n)} \\ 等价于 \\ ed - 1 = kφ(n) \\ 化简后为 \\ ed + kφ(n) = 1</script><p>​    </p><p>​    在这个式子中，d是我们要求解的模反元素，而k是一个任意值，所以在化简过程中并不涉及变号。这时候再看最后化简的等式，我们计算模反元素的过程已经变成了一个求二元一次方程解（ex + yφ(n) = 1）的问题。这里的这个问题可以通过<code>扩展欧几里得算法</code>进行计算。</p><blockquote><p><strong>扩展欧几里得算法</strong>（英语：Extended Euclidean algorithm）是<code>欧几里得算法</code>（又叫辗转相除法）的扩展。已知整数a、b，扩展欧几里得算法可以在求得a、b的最大公约数的同时，能找到整数x、y（其中一个很可能是负数），使它们满足<code>贝祖等式</code></p><script type="math/tex; mode=display">ax + by = gcd(a,b)</script><p>上面化简后的二元一次方程中a和b对应的分别是e和φ(n) ，我们知道e是与φ(n)互质的关系，那么gcd(e,φ(n)) = 1 成立，这里的二元一次方程就是一个贝祖等式。</p></blockquote><p>​    暂时copy一个扩展欧几里得算法（python实现)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eucild_ex</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        x = <span class="number">1</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> x,y,a</span><br><span class="line">    (x,y,r) = eucild_ex(b,a % b)</span><br><span class="line">    tmp = x</span><br><span class="line">    x = y</span><br><span class="line">    y = tmp - int(a/b)*y</span><br><span class="line">    <span class="keyword">return</span> (x,y,r)</span><br></pre></td></tr></table></figure><blockquote><p>将 a = e = 17, b = φ(n) = 3120 使用函数计算后得出结果<code>(-367, 2, 1)</code>,根据模反元素上面提到过的定义中，“ b+kn 都是a的模反元素”这一性质，我们可以得到一个最小的正整数模反元素 d = 2753</p></blockquote><p><strong>第六步，组装公钥和私钥</strong></p><p>​    现在我们有以下几个数字：</p><ul><li><p>p 随机选取的质数 61</p></li><li><p>q 随机选取的质数 53</p></li><li><p>n p与q的乘积 3233</p></li><li><p>φ(n) n的欧拉函数 3120</p></li><li><p>e 选择的一个与φ(n)互质的数字 17</p></li><li><p>d e的模反元素 2753</p><p>这里，我们选择n、e作为公钥，选择n、d为私钥</p></li></ul><blockquote><p>公钥 (n, e) -&gt; (3233, 17)</p><p>私钥 (n, d) -&gt; (3233, 2753)</p></blockquote><h3 id="加密和解密"><a href="#加密和解密" class="headerlink" title="#加密和解密"></a>#加密和解密</h3><p>​    有了公钥和私钥，我们就可以进行加密和解密了，我们假设当前有一段信息message，message字符串取其unicode值或者ascii值m，这里必须要求<strong>m小于n</strong>。我们假设m=65。</p><p><strong>加密过程</strong></p><p>​    加密需要使用公钥(n,e),所谓的加密，就是计算下面公式中的c</p><script type="math/tex; mode=display">m^e \equiv c \pmod n \\ 即 \\ 65^{17} \equiv c \pmod {3233}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pow(<span class="number">65</span>,<span class="number">17</span>) % <span class="number">3233</span></span><br></pre></td></tr></table></figure><p>​    计算得出，c的值为 2790。加密的信息2790就被发送给对方。</p><p><strong>解密过程</strong></p><p>​    解密过程需要使用私钥(n, d)，对方发来的加密信息是c = 2790，那么我们可以计算这样的一个算式：</p><script type="math/tex; mode=display">c^d \equiv m \pmod n \\即\\ 2790 ^{2753} \equiv m \pmod {3233}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pow(<span class="number">2790</span>,<span class="number">2753</span>) % <span class="number">3233</span></span><br></pre></td></tr></table></figure><p>​    通过计算得出，m = 65</p><p>​    至此，整个“加密-解密”过程全部完成。</p><h3 id="解密过程的证明"><a href="#解密过程的证明" class="headerlink" title="#解密过程的证明"></a>#解密过程的证明</h3><p>​    我们这里证明一下，为什么使用私钥解密可以正确的求得m。也就是证明下面的这个公式。</p><script type="math/tex; mode=display">c^d \equiv m \pmod n</script><p>​    这个公式可以根据加密规则化简一下</p><script type="math/tex; mode=display">m^e \equiv c \pmod n (加密公式) \\ 即 \\ c = m^e - kn \\ 代入加密公式 \\ {(m^e - kn)}^d \equiv m \pmod n</script><p>​    通过模运算的基本性质，最后这个算式等同于：</p><script type="math/tex; mode=display">m^{ed} \equiv m \pmod n</script><p>​    因为d是e的模反元素，所以满足公式：</p><p>​    </p><script type="math/tex; mode=display">ed\equiv 1 \pmod{φ(n)}</script><p>​    所以可以化简ed 并代入</p><script type="math/tex; mode=display">ed = hφ(n) + 1 \\ 代入后得到 \\ m^{hφ(n) + 1} \equiv m \pmod n</script><p>​    接下来对最后的算式进行一个讨论：</p><p><strong>当m与n互质</strong></p><p>​    根据欧拉定理，可以进行推导：</p><script type="math/tex; mode=display">m^{φ(n)}\equiv 1 \pmod n (欧拉定理) \\ 可以推得原式 \\ {(m^{φ(n)})}^h \times m \equiv m \pmod n</script><p>​    <strong>证毕。</strong></p><p><strong>当m和n不是互质关系</strong></p><p>​    因为n是两个质数的乘积，也就代表，n的因数只有p和q，而此时m和n不是互质关系，也就是说m和n存在一个公因子g，n=pq, m=kg。n只有p和q两个因子，所以k和g中必然有一个等于q或者p。所以，这里我们假设：<strong>m = kp</strong>，同时我们也可以确定，k和q必然互质。</p><p>​    使用欧拉定理可得到：</p><script type="math/tex; mode=display">{(kp)}^{(q-1)} \equiv 1 \pmod q \\ 进一步可以得到 \\ {[{(kp)}^{(q-1)}]}^{h(p-1)}  \times kp \equiv kp \pmod q \\ 即 \\ {(kp)}^{ed} \equiv kp \pmod q</script><p>​    这时我们可以将最后的算式改写成一个等式：</p><script type="math/tex; mode=display">{(kp)}^{ed} = tq + kp</script><p>​    在这个算式中，等号左边可以被p整除，那么同理tq+kp一定也可以被p整除，对于tq来说，q是与p互质，所以此时t一定是p的倍数。这里就令t = t’q。</p><script type="math/tex; mode=display">{(kp)}^{ed} = t'pq + kp \\m = kp,n=pq \\可以得到\\ m^{ed} \equiv m \pmod n</script><p><strong>证毕。</strong></p><p>​    在上面的证明中，算式的推导和化简离不开模运算的基本性质，例如进行幂运算之后的处理，无法理解的时候可以针对算式中的模等表示进行修改，改成kn + m 的形式，总而言之，理解模运算的本质是理解算式推导化简的关键。</p><h2 id="四、RSA算法的可靠性"><a href="#四、RSA算法的可靠性" class="headerlink" title="四、RSA算法的可靠性"></a>四、RSA算法的可靠性</h2><p>​    以上述例子为参考，我们在加密解密的过程中，一共产生了六个数字，他们是：</p><ul><li>p 随机选取的质数 61</li><li>q 随机选取的质数 53</li><li>n p与q的乘积 3233</li><li>φ(n) n的欧拉函数 3120</li><li>e 选择的一个与φ(n)互质的数字 17</li><li>d e的模反元素 2753</li></ul><p>​    在这六个数字中，公钥用到了n和e，其他四个数字都是不公开的，对于私钥n和d来说，最关键的就是d，一旦d泄漏，那么就等同于私钥泄漏。</p><p>​    那么，在已知n和e的情况下，是否可以推导出d？</p><blockquote><ol><li>ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d (模反元素)</li><li>φ(n) = （p - 1) (q - 1). 只有知道p和q才能算出φ(n)</li><li>n = pq。只有将n因数分解，才能算出p和q</li></ol></blockquote><p>​    也就是说，我们想要破解RSA算法，最直接也是最简单的方法就是对n进行质因数分解，我们可以对3233进行因数分解（61 * 53）但是如果是下面这样一个整数呢？</p><blockquote><p>123018668453011775513049495838496272077285356959533479219732245215172640050726<br>365751874520219978646938995647494277406384592519255732630345373154826850791702<br>6122142913461670429214311602221240479274737794080665351419597459856902143413</p></blockquote><p>这个整数等于这样两个质数的乘积：</p><blockquote><p>334780716989568987860441698482126908177047949837137685689124313889828837938780<br>02287614711652531743087737814467999489<br>　　　　×<br>367460436667995904282446337996279526322791581643430876426760322838157396665112<br>79233373417143396810270092798736308917</p></blockquote><p>​    在这种情况下，想要破解RSA算法而进行因数分解，恐怕就是一个复杂度无法想象的问题。</p><p><strong>以上！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring自动装配的一次踩坑经历</title>
      <link href="/2020/09/05/Spring%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E4%B8%80%E6%AC%A1%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
      <url>/2020/09/05/Spring%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E4%B8%80%E6%AC%A1%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="零、写在前面"><a href="#零、写在前面" class="headerlink" title="零、写在前面"></a>零、写在前面</h2><blockquote><p> 众所周知，程序员计数都是从零开始的。</p></blockquote><p>​    最近组长给安排了一个组内“分享”，一般来说都是技术分享，但是可能是鉴于我分享不出来什么对他们有用的技术，所以给我定了个主题是“分享公司的人员组织架构、组内服务功能，系统架构”，硬着头皮写了写自己知道的，准备了两周，每天都在觉得ppt上写的是一堆废话。</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/IMG_9909.JPG" alt="IMG_9909" style="zoom: 33%;" /></p><p>​    终于在度过了极其自闭的两周，ppt无惊无险的讲完了，上周单休，被小伙伴拉去打了游戏，所以上周学习进度也是0。</p><p>淦！这个题目好像是一个月之前想写的了,最近实在是太懒惰了😭😭😭。。。。</p><h2 id="一、踩坑"><a href="#一、踩坑" class="headerlink" title="一、踩坑"></a>一、踩坑</h2><p>​    事情从一次普通的需求说起，业务上的代码需要在一个Util类上进行改动，但是同时还是需要调用一些其他service方法，这里就需要通过Spring进行装配，但是改动的方法是一个static的静态方法，这里我就脑抽的直接使用了static关键字修饰引用的service。</p><blockquote><p>其实这里是不对的，Utils是不可以有任何service层的调用的，这里我通过沟通也进行了改动，将service的调用移到了Utils调用之前，将service的调用结果处理后作为Utils的参数。但正因为这样，奉行ctrl c、ctrl v的我，还是把static给复制了过来😅。</p></blockquote><p>示例代码 👇🏻：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TestService testService; <span class="comment">//the bean is modified by static!!!!</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/foo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiResult <span class="title">fooController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String msg = testService.testAutowired(<span class="string">"this is a msg"</span>);</span><br><span class="line">        System.err.println(msg);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.success(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们如果去掉static，按照传统的装配方式，当然可以正常的请求到这个方法，并且返回一个json👇🏻：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="number">0</span>,<span class="attr">"message"</span>:<span class="string">"Success"</span>,<span class="attr">"data"</span>:<span class="string">"this is a msg"</span>&#125;</span><br></pre></td></tr></table></figure><p>但是，既然是坑，那么一定是出错了才对。。。</p><p>没错，在上面示例代码的情况下进行请求，会爆出一个NullPointerException，错误堆栈如下👇🏻:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">There was an unexpected <span class="title">error</span> <span class="params">(type=Internal Server Error, status=<span class="number">500</span>)</span>.</span></span><br><span class="line"><span class="function">No message available</span></span><br><span class="line"><span class="function">java.lang.NullPointerException</span></span><br><span class="line"><span class="function">at com.lcl.datareplenish.controller.ModelController.<span class="title">fooController</span><span class="params">(ModelController.java:<span class="number">27</span>)</span></span></span><br><span class="line"><span class="function">at sun.reflect.NativeMethodAccessorImpl.<span class="title">invoke0</span><span class="params">(Native Method)</span></span></span><br><span class="line"><span class="function">at sun.reflect.NativeMethodAccessorImpl.<span class="title">invoke</span><span class="params">(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span></span></span><br><span class="line"><span class="function">at sun.reflect.DelegatingMethodAccessorImpl.<span class="title">invoke</span><span class="params">(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span></span></span><br><span class="line"><span class="function">at java.lang.reflect.Method.<span class="title">invoke</span><span class="params">(Method.java:<span class="number">498</span>)</span></span></span><br><span class="line"><span class="function">at org.springframework.web.method.support.InvocableHandlerMethod.<span class="title">doInvoke</span><span class="params">(InvocableHandlerMethod.java:<span class="number">190</span>)</span></span></span><br><span class="line"><span class="function">at org.springframework.web.method.support.InvocableHandlerMethod.<span class="title">invokeForRequest</span><span class="params">(InvocableHandlerMethod.java:<span class="number">138</span>)</span></span></span><br><span class="line"><span class="function">at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.<span class="title">invokeAndHandle</span><span class="params">(ServletInvocableHandlerMethod.java:<span class="number">106</span>)</span></span></span><br><span class="line"><span class="function">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.<span class="title">invokeHandlerMethod</span><span class="params">(RequestMappingHandlerAdapter.java:<span class="number">888</span>)</span></span></span><br><span class="line"><span class="function">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.<span class="title">handleInternal</span><span class="params">(RequestMappingHandlerAdapter.java:<span class="number">793</span>)</span></span></span><br><span class="line"><span class="function">at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.<span class="title">handle</span><span class="params">(AbstractHandlerMethodAdapter.java:<span class="number">87</span>)</span></span></span><br><span class="line"><span class="function">at org.springframework.web.servlet.DispatcherServlet.<span class="title">doDispatch</span><span class="params">(DispatcherServlet.java:<span class="number">1040</span>)</span></span></span><br><span class="line"><span class="function">at org.springframework.web.servlet.DispatcherServlet.<span class="title">doService</span><span class="params">(DispatcherServlet.java:<span class="number">943</span>)</span></span></span><br><span class="line"><span class="function">at org.springframework.web.servlet.FrameworkServlet.<span class="title">processRequest</span><span class="params">(FrameworkServlet.java:<span class="number">1006</span>)</span></span></span><br><span class="line"><span class="function">at org.springframework.web.servlet.FrameworkServlet.<span class="title">doGet</span><span class="params">(FrameworkServlet.java:<span class="number">898</span>)</span></span></span><br><span class="line"><span class="function">at javax.servlet.http.HttpServlet.<span class="title">service</span><span class="params">(HttpServlet.java:<span class="number">634</span>)</span></span></span><br><span class="line"><span class="function">at org.springframework.web.servlet.FrameworkServlet.<span class="title">service</span><span class="params">(FrameworkServlet.java:<span class="number">883</span>)</span></span></span><br><span class="line"><span class="function">at javax.servlet.http.HttpServlet.<span class="title">service</span><span class="params">(HttpServlet.java:<span class="number">741</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.catalina.core.ApplicationFilterChain.<span class="title">internalDoFilter</span><span class="params">(ApplicationFilterChain.java:<span class="number">231</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.catalina.core.ApplicationFilterChain.<span class="title">doFilter</span><span class="params">(ApplicationFilterChain.java:<span class="number">166</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.tomcat.websocket.server.WsFilter.<span class="title">doFilter</span><span class="params">(WsFilter.java:<span class="number">53</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.catalina.core.ApplicationFilterChain.<span class="title">internalDoFilter</span><span class="params">(ApplicationFilterChain.java:<span class="number">193</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.catalina.core.ApplicationFilterChain.<span class="title">doFilter</span><span class="params">(ApplicationFilterChain.java:<span class="number">166</span>)</span></span></span><br><span class="line"><span class="function">at org.springframework.web.filter.RequestContextFilter.<span class="title">doFilterInternal</span><span class="params">(RequestContextFilter.java:<span class="number">100</span>)</span></span></span><br><span class="line"><span class="function">at org.springframework.web.filter.OncePerRequestFilter.<span class="title">doFilter</span><span class="params">(OncePerRequestFilter.java:<span class="number">119</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.catalina.core.ApplicationFilterChain.<span class="title">internalDoFilter</span><span class="params">(ApplicationFilterChain.java:<span class="number">193</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.catalina.core.ApplicationFilterChain.<span class="title">doFilter</span><span class="params">(ApplicationFilterChain.java:<span class="number">166</span>)</span></span></span><br><span class="line"><span class="function">at org.springframework.web.filter.FormContentFilter.<span class="title">doFilterInternal</span><span class="params">(FormContentFilter.java:<span class="number">93</span>)</span></span></span><br><span class="line"><span class="function">at org.springframework.web.filter.OncePerRequestFilter.<span class="title">doFilter</span><span class="params">(OncePerRequestFilter.java:<span class="number">119</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.catalina.core.ApplicationFilterChain.<span class="title">internalDoFilter</span><span class="params">(ApplicationFilterChain.java:<span class="number">193</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.catalina.core.ApplicationFilterChain.<span class="title">doFilter</span><span class="params">(ApplicationFilterChain.java:<span class="number">166</span>)</span></span></span><br><span class="line"><span class="function">at org.springframework.web.filter.CharacterEncodingFilter.<span class="title">doFilterInternal</span><span class="params">(CharacterEncodingFilter.java:<span class="number">201</span>)</span></span></span><br><span class="line"><span class="function">at org.springframework.web.filter.OncePerRequestFilter.<span class="title">doFilter</span><span class="params">(OncePerRequestFilter.java:<span class="number">119</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.catalina.core.ApplicationFilterChain.<span class="title">internalDoFilter</span><span class="params">(ApplicationFilterChain.java:<span class="number">193</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.catalina.core.ApplicationFilterChain.<span class="title">doFilter</span><span class="params">(ApplicationFilterChain.java:<span class="number">166</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.catalina.core.StandardWrapperValve.<span class="title">invoke</span><span class="params">(StandardWrapperValve.java:<span class="number">202</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.catalina.core.StandardContextValve.<span class="title">invoke</span><span class="params">(StandardContextValve.java:<span class="number">96</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.catalina.authenticator.AuthenticatorBase.<span class="title">invoke</span><span class="params">(AuthenticatorBase.java:<span class="number">526</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.catalina.core.StandardHostValve.<span class="title">invoke</span><span class="params">(StandardHostValve.java:<span class="number">139</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.catalina.valves.ErrorReportValve.<span class="title">invoke</span><span class="params">(ErrorReportValve.java:<span class="number">92</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.catalina.core.StandardEngineValve.<span class="title">invoke</span><span class="params">(StandardEngineValve.java:<span class="number">74</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.catalina.connector.CoyoteAdapter.<span class="title">service</span><span class="params">(CoyoteAdapter.java:<span class="number">343</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.coyote.http11.Http11Processor.<span class="title">service</span><span class="params">(Http11Processor.java:<span class="number">408</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.coyote.AbstractProcessorLight.<span class="title">process</span><span class="params">(AbstractProcessorLight.java:<span class="number">66</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.coyote.AbstractProtocol$ConnectionHandler.<span class="title">process</span><span class="params">(AbstractProtocol.java:<span class="number">861</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.<span class="title">doRun</span><span class="params">(NioEndpoint.java:<span class="number">1579</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.tomcat.util.net.SocketProcessorBase.<span class="title">run</span><span class="params">(SocketProcessorBase.java:<span class="number">49</span>)</span></span></span><br><span class="line"><span class="function">at java.util.concurrent.ThreadPoolExecutor.<span class="title">runWorker</span><span class="params">(ThreadPoolExecutor.java:<span class="number">1149</span>)</span></span></span><br><span class="line"><span class="function">at java.util.concurrent.ThreadPoolExecutor$Worker.<span class="title">run</span><span class="params">(ThreadPoolExecutor.java:<span class="number">624</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.<span class="title">run</span><span class="params">(TaskThread.java:<span class="number">61</span>)</span></span></span><br><span class="line"><span class="function">at java.lang.Thread.<span class="title">run</span><span class="params">(Thread.java:<span class="number">748</span>)</span></span></span><br></pre></td></tr></table></figure><p>​    而且也可以在日志中找到两行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">09</span>-<span class="number">06</span> <span class="number">01</span>:<span class="number">47</span>:<span class="number">04.216</span>  INFO <span class="number">71855</span> --- [  restartedMain] f.a.AutowiredAnnotationBeanPostProcessor : Autowired annotation is not supported on <span class="keyword">static</span> fields: <span class="keyword">private</span> <span class="keyword">static</span> com.lcl.datareplenish.service.TestService com.lcl.datareplenish.controller.ModelController.testService</span><br><span class="line"><span class="number">2020</span>-<span class="number">09</span>-<span class="number">06</span> <span class="number">01</span>:<span class="number">47</span>:<span class="number">04.216</span>  INFO <span class="number">71855</span> --- [  restartedMain] f.a.AutowiredAnnotationBeanPostProcessor : Autowired annotation is not supported on <span class="keyword">static</span> fields: <span class="keyword">private</span> <span class="keyword">static</span> com.lcl.datareplenish.service.TestService com.lcl.datareplenish.controller.ModelController.testService</span><br></pre></td></tr></table></figure><p>​    经过资料的查阅，会发生这种问题关键在于Spring容器与类加载的先后顺序问题。</p><h2 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h2><p>​    <strong>首先对static关键字进行分析</strong>，深入探究staic要从Java的内存模型层次上进行分析，这篇文章就先不讨论那么深入，日后在我继续读《深入理解JVM虚拟机》之后应该会进行总结的。</p><p>​    首先我们知道一个常识，静态变量（成员）它是<strong>属于类</strong>的，而非属于实例对象的属性；同样的静态方法也是属于类的，普通方法（实例方法）才属于对象。</p><pre><code>&gt; 突然有些理解，被autowired注解修饰的引用，其实是当前类的一个属性，而进行的注入，无非是通过了Spring容器将生成好的bean作为初始化赋值给当前的这个属性。这才是所谓的依赖注入。</code></pre><p>​    而Spring容器管理的都是<strong>实例对象</strong>，包括它的<code>@Autowired</code>依赖注入的均是容器内的对象实例，所以对于static成员是不能直接使用<code>@Autowired</code>注入的。</p><p>​    也就是说，类的static属性在Spring容器启动之前就已经加载了，而且它并不依靠Spring的依赖注入来进行初始化的。</p><p>​    而且Spring官方也是非常不建议对static属性字段进行依赖注入（这里是不建议，而不是不可以） 。</p><p><strong>那么Spring容器是如何在自动装配的时候做到避免static字段的bean的生成呢？</strong></p><p>​    从上述的两行<code>not supported on static fields</code>的日志中可以定位到Spring的部分源码👇🏻：</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20200906020204050.png" alt="image-20200906020204050"></p><p>​    从这个上面可以看到，当field或者是method被<code>static</code>修饰之后，Spring就会自动跳过他们，仅仅只会打出一行info级别的日志，但是不会发生依赖注入，所以也就导致了后面再调用时会发生NullPointerException异常。</p><h2 id="三、问题解决"><a href="#三、问题解决" class="headerlink" title="三、问题解决"></a>三、问题解决</h2><p>​    虽然我们不能使用传统的注解的方式对static属性进行依赖注入，那么是不是代表我们没有方法调用静态属性了呢？ 当然不是！</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>使用一个set方法👇🏻：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestService</span><span class="params">(TestService testService)</span> </span>&#123;</span><br><span class="line">        ModelController.testService = testService;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/foo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiResult <span class="title">fooController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String msg = testService.testAutowired(<span class="string">"this is a msg"</span>);</span><br><span class="line">        System.err.println(msg);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.success(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>使用<code>@PostConstruct</code>注解，为static成员赋值👇🏻：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TestService testService;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ModelController.testService = applicationContext.getBean(TestService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/foo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiResult <span class="title">fooController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String msg = testService.testAutowired(<span class="string">"this is a msg"</span>);</span><br><span class="line">        System.err.println(msg);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.success(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><p>实现一个SpringContext的工具类，去获取容器中的bean👇🏻：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/foo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiResult <span class="title">fooController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//未提供SpringApplicationContextUtil类的实现</span></span><br><span class="line">        testService =  SpringApplicationContextUtil.getBean(<span class="string">"testService"</span>); </span><br><span class="line">        String msg = testService.testAutowired(<span class="string">"this is a msg"</span>);</span><br><span class="line">        System.err.println(msg);</span><br><span class="line">        <span class="keyword">return</span> ApiResult.success(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、写在最后"><a href="#四、写在最后" class="headerlink" title="四、写在最后"></a>四、写在最后</h2><p>​    这次踩坑其实并没有任何人发现，只是在我自己部署到测试环境之后，自己发现的问题（多亏没被别人发现，不然丢死人了😣），在问题原因的探究过程中发现了自己对Spring甚至是static都还理解的不够透彻。</p><p>​    比如：</p><ul><li>static所修饰的成员变量在加载过程中的特殊性</li><li>“Spring容器启动跳过static成员注入”操作的入口</li><li>Spring的依赖注入所解决的问题</li></ul><p>​    未来要学习内容与方向：</p><ul><li>Java内存模型——《深入理解JVM虚拟机》</li><li>Spring的底层原理与源码实现——《Spring源码深度解析》</li></ul><p>​    道阻且长，继续加油💪🏻。</p><p><strong>以上！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> workReview </tag>
            
            <tag> ExceptionRecord </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的工作原理(二)：HashMap中的数据结构与原理</title>
      <link href="/2020/07/26/HashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E4%BA%8C-%EF%BC%9AHashMap%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
      <url>/2020/07/26/HashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E4%BA%8C-%EF%BC%9AHashMap%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="1、哈希表概述"><a href="#1、哈希表概述" class="headerlink" title="1、哈希表概述"></a>1、哈希表概述</h3><p>​    在了解什么是HashMap之前，我们首先要了解哈希表（Hash table）：</p><blockquote><p>哈希表（hash table）<br>也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存</p><p>张大的哈希表. </p></blockquote><p>​    首先，与哈希表进行区别，我们要了解一下其他数据结构在新增、查找等基础操作的执行性能. </p><p><strong>数组：</strong></p><p>​    数组采用一段连续的存储单元来进行数据存储，对于指定下标的查找，时间复杂度为O(1)；通过给定值的查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，对于有序数组当然可以采用二分查找、差值查找，斐波那契查找等方式，可以讲查找复杂度提高到O(logn)；对于一般的插入、删除操作，涉及到数组元素的移动，平均复杂度为O(n)。</p><p>​    数组在内存中查找位置满足公式：</p><blockquote><p>a[i]_address = base_address + i*data_type_size</p></blockquote><p>​    这里的base_address代表数组头节点内存地址，i表示为下标，data_type_size表示每个节点的大小，所以通过这个公式计算，可以快速定位到指定下标的元素，这也是为什么数组下标第一个是0的原因了（减少一次减法运算，提高效率）。</p><p><strong>线性链表：</strong></p><p>​    对于链表的新增、删除等操作，只需要处理节点之间的引用即可，这样的话时间复杂度就是O(1)，而查找操作需要遍历链表注意进行比对，复杂度为O(n)。</p><p><strong>二叉树：</strong></p><p>​    对于一颗相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p><p><strong>哈希表：</strong></p><p>​    相比于以上数据结构，在哈希表中进行添加、删除、查找等操作，性能十分高，在不考虑哈希冲突的情况下。仅需要一次定位即可完成，时间复杂度为O(1). </p><p>​    哈希表的主体是一个数组，一般被称为bucket数组，在这个bucket中存放着我们需要保存的数据元素，在我们进行保存的时候，通过对数据hash值与bucket数组长度之间进行运算，可以得到当前元素要存储的位置。也就是说通过某种函数映射，将元素映射到bucket中的特定位置上，有了这个位置我们就可以进行快速的数据查找定位。</p><h3 id="2、HashMap的数据结构"><a href="#2、HashMap的数据结构" class="headerlink" title="2、HashMap的数据结构"></a>2、HashMap的数据结构</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>​    HashMap最早出现在JDK 1.2中，底层基于散列算法实现。HashMap允许null键和null值，在计算null键的哈希值时，null键哈希值为0。HashMap并不保证键值对的顺序，这意味着在进行某些操作之后，键值对的顺序可能会发生变化。另外，HashMap是非线程安全的类，在多线程环境下可能存在问题。</p><p>​    jdk1.8之前采用的是数组+链表的数据结构，每个元素都是一个Entry结点，包含key、value、hash值、指向下一个元素的next指针四个属性。jdk1.8之后采用的是数组+链表或者是红黑树的数据结构，每一个元素都是一个Node结点，Node实现了Entry接口，Node有一个子类TreeNode，代表树结点。</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20200726164635518.png" alt="image-20200726164635518"  /></p><h4 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h4><p>在进行增删查等操作时，首先要定位到元素在数组（bucket数组）中的位置，而定位这个位置的方法就是“散列算法”，也叫哈希函数。</p><p>散列算法：我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。</p><p>这个算法在HashMap的实现方法是用hashcode对数组长度进行取模运算，也就是：</p><blockquote><p>index = hashcode % length（举例来说 定位元素35在桶数组中的位置：index = 35（取其hash）% 16（hashMap初始化长度）</p></blockquote><p>图中的查询方法简单举例就是 index = 35 % 16 = 3 然后再在3号桶所指向的链表中继续查找，35就在链表中.</p><h4 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h4><p>​    散列冲突也叫哈希碰撞、哈希冲突。正如万事无完美，如果两个不同的元素，通过散列算法计算出的存储地址相同该怎么办呢？也就是说，我们在对元素进行散列算法确定位置之后，发现当前位置上已经有了元素这就是我们所说的散列冲突。</p><p><strong>解决方法：</strong></p><ol><li><p><strong>开放寻址法</strong></p><p>开放寻址的思想就是，出现了散列冲突之后，我们就重新找到一个空闲位置将其插入，重新探测位置的方法有很多，比如，<strong>线性探测(Linear Probing)</strong>。</p><p><strong>线性探测：</strong></p><p>​    当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p><p>​    对于线性探测的查找有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。<strong>如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。</strong></p><p>​    但是线性探测的一个重要问题就是他的删除操作，我们在删除元素的时候不能单纯的把元素设置为空，因为在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是如果这个位置就是我们刚刚删除的，那这个查找算法就失效了，原来存在的数据会被认定为不存在，所以我们在删除元素时，应该将删除的元素标记为一个deleted状态，这个时候我们进行查找，就可以继续向下探测了。</p><blockquote><p>由此可以看到，线性探测有很大的问题，当我们插入的数据越来越多，空闲位置越来越少，那这个时候就会更容易产生冲突，而由此会浪费大量的时间在探测这个操作上，极端情况下还容易探测整张表，这样的效率极其低下。除了线性探测之外重新探测的方式还有 <strong>二次探测(Quadratic probing)</strong>和 <strong>双重散列(Double hashing)</strong></p></blockquote></li><li><p><strong>链表法</strong></p><p>​    链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p><p>​    插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。</p><p>​    <strong>我们在HashMap中采用的正是链表法，而且在链表过长时还会转化成为红黑树，来保证效率。</strong></p></li></ol><h3 id="3、HashMap中的数据结构实现"><a href="#3、HashMap中的数据结构实现" class="headerlink" title="3、HashMap中的数据结构实现"></a>3、HashMap中的数据结构实现</h3><h4 id="Bucket数组"><a href="#Bucket数组" class="headerlink" title="Bucket数组"></a>Bucket数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>Bucket数组就是一个Node<K,V>类型的数组，使用了<code>transient</code>关键字修饰</p><blockquote><ol><li>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li><li>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</li><li>一个静态变量不管是否被transient修饰，均不能被序列化。 </li></ol></blockquote><p>在HashMap源码中，我们经常可以看到transient修饰其固有属性，大概是为了序列化的安全性。</p><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node<K, V></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Node类是HashMap的一个静态内部类，实现了Map.Entry<K, V>接口。</p><p>从代码中我们可以看到，Node的属性有K的Hash值，具体的Key、Value以及指向下一个Node的Next指针。</p><p>同时，Node也对其父接口中的抽象方法进行了具体的实现. </p><h4 id="EntrySet"><a href="#EntrySet" class="headerlink" title="EntrySet"></a>EntrySet</h4><p>通常我们在遍历一个Map的时候，通常直接使用使用它的<code>entrySet()</code>方法进行遍历，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//set sth into hashmap ...</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; stringStringEntry : hashMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(stringStringEntry.getKey());</span><br><span class="line">            System.out.println(stringStringEntry.getValue());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在HashMap的源码中，我们可以看到entrySet()方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the mappings contained in this map.</span></span><br><span class="line"><span class="comment"> * The set is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment"> * reflected in the set, and vice-versa.  If the map is modified</span></span><br><span class="line"><span class="comment"> * while an iteration over the set is in progress (except through</span></span><br><span class="line"><span class="comment"> * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the</span></span><br><span class="line"><span class="comment"> * iterator) the results of the iteration are undefined.  The set</span></span><br><span class="line"><span class="comment"> * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment"> * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a set view of the mappings contained in this map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就不得不让人发觉一个问题，在单纯调用entrySet这个方法的时候，只是返回了一个新的entrySet，那么为什么我们仍然可以在entrySet中访问到HashMap的key和value值呢？</p><p>我们从EntrySet的源码进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        Object key = e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Object value = e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们要明确一个问题，EntrySet是继承自AbstractSet类的，也就是说，EntrySet本质上是一个Set集合，而对于一个Set集合，我们应当明白：</p><blockquote><p>Set不提供Get方法，所以我们无法直接获取Set中的元素 . </p><p>对于一个Set集合，我们想要对他进行遍历，只有两个方法：</p><ol><li>使用迭代器Iterator进行迭代</li><li>使用增强for循环</li></ol><p>而增强for循环，本质上就是使用了迭代器。</p></blockquote><p>由于EntrySet只能被迭代器访问到其中元素，所以我们只需要关注Iterator方法中调用的<strong>new EntryIterator()</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] t;</span><br><span class="line">    Node&lt;K,V&gt; e = next;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EntryIterator迭代器的next()方法，是获取HashMap中的next元素，所以实际上在这里迭代到的，是HashMap的元素，这也就是为什么EntrySet是有值的原因.</p><p>​    以上！🙏</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> DataStructure </tag>
            
            <tag> Algorithm </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的工作原理(一)：Hash算法</title>
      <link href="/2020/06/07/HashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E4%B8%80-%EF%BC%9AHash%E7%AE%97%E6%B3%95/"/>
      <url>/2020/06/07/HashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E4%B8%80-%EF%BC%9AHash%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1、什么是Hash"><a href="#1、什么是Hash" class="headerlink" title="1、什么是Hash"></a>1、什么是Hash</h3><p>​    Hash也被称为散列、哈希，对应的英文都是Hash.他们的基本原理都是<strong>把任意长度的输入，通过Hash算法变成固定长度的输出.</strong>这个映射的规则就是对应的Hash算法，而原始数据映射之后的二进制串就是哈希值. 经常使用的Hash算法有MD5和SHA，他们都是历史悠久的Hash算法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hash算法"</span>;</span><br><span class="line">System.err.println(md5(s));</span><br><span class="line"><span class="comment">// 输出结果：f1ab62697296f0b575b9229dba7ea1ba</span></span><br></pre></td></tr></table></figure><p>​    这个例子中，<code>&quot;Hash算法&quot;</code>是原始值，<code>f1ab62697296f0b575b9229dba7ea1ba</code>则是通过这种md5的hash算法得到的Hash值。整个Hash算法的过程就是<strong>把原始任意长度的值空间映射成固定长度的值空间的过程</strong>.</p><blockquote><p>对于Hash算法来说，主要会在数据结构和密码学中得到应用，在这两种不同的领域，算法的设计重点也是不同的.</p></blockquote><h3 id="2、Hash算法的特点"><a href="#2、Hash算法的特点" class="headerlink" title="2、Hash算法的特点"></a>2、Hash算法的特点</h3><p>​    hash算法作为一个算法，有许多不同的实现方式，比如上面说的MD5或者SHA. 这些算法除了满足上述Hash的基本功能之外，也需要有其他的特点来确保他是一个可用的、合理的、优秀的Hash算法. </p><ul><li><p>从Hash值<strong>不可以</strong>反向推导出原始的数据</p><p>经过Hash映射之后的数据和原始数据没有对应关系</p></li><li><p>Hash算法的执行效率要高效，长的文本或字符串能够很快的计算出哈希值</p></li><li><p>输入数据的微小变化会得到<strong>完全不同</strong>的Hash值，相同的数据会得到相同的值</p><p>这里也可以说Hash算法的<strong>抗篡改能力：对于一个数据块，哪怕只修改一个比特位，其Hash值的改动也会非常大. </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hash算法"</span>;</span><br><span class="line">System.err.println(md5(s));</span><br><span class="line"><span class="comment">// 输出结果：f1ab62697296f0b575b9229dba7ea1ba</span></span><br><span class="line">String s = <span class="string">"Hash算法"</span>;</span><br><span class="line">System.err.println(md5(s));</span><br><span class="line"><span class="comment">// 输出结果：d789d51b7005d2d55c23bbfc4367d97d</span></span><br></pre></td></tr></table></figure><p>通过这个实例我们可以看到，只是改变了一个字符，却能导致两个hash值几乎每一位都不同.</p></li><li><p>Hash算法的冲突概率要小</p><p>Hash算法的原理是把输入空间的值映射到Hash空间内，由于Hash值的空间远小于输入的空间，而且借助<strong>抽屉原理</strong>，可以得出一个结论——一定会存在不同的输入被映射成相同输出的情况，如果一个Hash算法足够好，那么他就一定会有更小的发生冲突的概率.  也就是说，一个好的Hash算法应该具有优秀的<strong>抗碰撞能力</strong></p><p><strong>抗碰撞能力：对于任意两个不同的数据块，其Hash值相同的可能性极小；对于一个给定的数据块，找到一个和他Hash值相同的数据块是极为困难的. </strong></p><blockquote><p><strong>抽屉原理</strong></p><p>桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面放不少于两个苹果。这一现象就是我们所说的“抽屉原理”。抽屉原理的一般含义为：“如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。” 抽屉原理有时也被称为鸽巢原理。它是组合数学中一个重要的原理</p></blockquote></li></ul><h3 id="3、数据结构中的Hash"><a href="#3、数据结构中的Hash" class="headerlink" title="3、数据结构中的Hash"></a>3、数据结构中的Hash</h3><p>​    在使用到Hash进行管理的数据结构中，比如HashMap，在这种数据结构中，Hash值（Key）存在的目的就是<strong>加速键值对的查找</strong>，因为HashMap的桶数组的容量是有限的，而且HashMap也采用了一系列的方法来进行碰撞处理，所以对于数据结构中的Hash，对抗碰撞能力的要求并不是很高. </p><p>​    但是对于HashMap的set操作，需要实现快速存储，那么这里就要求Hash算法的速度尽可能的快了. </p><h3 id="4、密码学中的Hash"><a href="#4、密码学中的Hash" class="headerlink" title="4、密码学中的Hash"></a>4、密码学中的Hash</h3><p>​    在密码学中，Hash算法的作用主要在于消息摘要或者是签名. 比如我们在登录某些网站的时候，需要输入密码来完成登陆操作，对于这些网站的运营商来说，明文保存密码是万万不可的，所以大部门网站的解决方式就是用Hash算法去生成密码的签名也就是他的Hash值，运营商后台去保存这个Hash值. 由于Hash算法的不可逆的特点，即使黑客拿到了这个Hash值，也不可以推出密码. </p><p>​    这样的场景里面，Hash算法的速度显得并不是那么重要了，与之相对的，抗碰撞和抗篡改能力要求极高. 一个优秀的Hash算法他的抗碰撞能力是非常强大的. 以MD5为例，输出长度为128位，设计预期的碰撞概率是<strong>1/2<sup>64</sup></strong>，这是一个极小的数字. </p><blockquote><p>2004年8月17日的美国加州圣巴巴拉，正在召开的国际密码学会议（Crypto’2004）安排了三场关于杂凑函数的特别报告。其中来自山东大学的王小云教授做了破译MD5、HAVAL-128、 MD4和RIPEMD算法的报告。</p><p>在会场上，当她公布了MD系列算法的破解结果之后，报告被激动的掌声打断。她的研究成果作为密码学领域的重大发现宣告了固若金汤的世界通行密码标准MD５的堡垒轰然倒塌，引发了密码学界的轩然大波。</p><p>经过了王小云教授的破解之后，MD5的碰撞上限被降低至1/2<sup>41</sup></p></blockquote><p>​    即使是降低到了1/2<sup>41</sup>，这也是一个很小的数字，也就是需要经过<strong>2<sup>40</sup></strong>次查找，才能有1/2的概率来找到一个和目标文件相同的Hash值.  </p><h3 id="5、Random-Oracle"><a href="#5、Random-Oracle" class="headerlink" title="5、Random Oracle"></a>5、Random Oracle</h3><blockquote><p>有没有可能找到这么一个算法，如果输出长度为128位，那么把这128位“充分利用到”，让它可以有1/2<sup>128</sup>种不同的hash值，而且分布均匀，抗篡改能力也特别高，一点点改动就会让hash值面目全非，一点都不浪费（这里的表述非常不严格）？稍微严格一点表述，就是：<strong>有没有这样一个算法，使得对于任何一个给定的输入，此算法都会输出一个固定的均匀随机的输出？</strong></p></blockquote><p>问题的答案是密码学家们到现在也没有能力去构造出一个这样的算法，但是大家更加倾向于这个算法是存在的，而且有不少的密码学算法构造和这个假设有关，这个假设的名字就是Random Oracle（随机预言机）</p><h3 id="6、Hash的应用"><a href="#6、Hash的应用" class="headerlink" title="6、Hash的应用"></a>6、Hash的应用</h3><ul><li><p>应用一：<strong>安全加密</strong></p><p>上述的密码学中的Hash，在安全加密的应用比较广泛. </p><p>不过需要知道的是，现在的世界上没有一个绝对安全的加密. 越复杂、越难破解的加密算法，需要计算的时间就越长. 密码学界一直在致力去找一种可以快速生成并且很难被破解的Hash算法. 而且我们在实际的开发中，也需要权衡破解难度和计算时间，来决定究竟使用哪种加密算法. </p></li><li><p>应用二：<strong>唯一标识</strong></p><p>由于Hash算法的抗碰撞能力，我们可以对一些难以查找、比较的文件或者其他的数据进行Hash计算，生成一个Hash值，也就是他的唯一标识. 这样去判断文件是否存在这样的操作就会简单很多. </p></li><li><p>应用三：<strong>数据校验</strong></p><p>BT种子下载软件的原理是基于P2P协议的，从多个机器上下载一个2GB的电影，这个电影文件可能会被分成很多块，等所有块下载好然后组装成一个完整电影. </p><p>网络传输是不安全的，所以下载出来的文件块是可能不完整的，这个时候我们就可以通过对文件块进行Hash运算，在下载之后和之前的Hash值进行对比，就可以进行数据校验. </p></li><li><p>应用四：<strong>散列函数</strong></p><p>基本用在数据结构中，散列表的实现. </p></li><li><p>应用五：<strong>负载均衡</strong></p><p>在分布式系统中，需要应用负载均衡的方式去将会话的请求分发给不同的服务器. 这里我们可以使用Hash算法对客户端IP进行计算Hash值，与服务器列表大小进行取模运算，获取对应需要被路由道的服务器编号. </p></li><li><p>应用六：<strong>数据分片</strong></p><p>一般都在应用于分布式解决问题，分治的思想，通过Hash来进行分区域分片实现“分”的操作.</p></li><li><p>应用七：<strong>分布式存储</strong></p><p>通过Hash值确定数据要存储到哪台机器上；如果机器新增了，数量改变了，我们可以通过<strong>一致性hash算法</strong>来避免大量的数据搬运. </p></li></ul><h3 id="7、一致性Hash算法"><a href="#7、一致性Hash算法" class="headerlink" title="7、一致性Hash算法"></a>7、一致性Hash算法</h3><blockquote><p>一致性哈希算法在1997年由麻省理工学院提出，是一种特殊的哈希算法，目的是解决分布式缓存的问题。 在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式哈希表( Distributed Hash Table，DHT) 中存在的动态伸缩等问题</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> DataStructure </tag>
            
            <tag> Algorithm </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客的部署与图床使用</title>
      <link href="/2020/05/23/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%9B%BE%E5%BA%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/05/23/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%9B%BE%E5%BA%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>将博客用hexo搭建好之后，我们应该明白，我们的博客不能一直处于本地环境启动，我们需要把它作为一个可以公共访问的网站来使用.</p><p>并且作为支持markdown语法的博客，在写博文时插入图片也需要图床的设置。</p></blockquote><h2 id="一、使用GitHub-pages部署hexo博客"><a href="#一、使用GitHub-pages部署hexo博客" class="headerlink" title="一、使用GitHub pages部署hexo博客"></a>一、使用GitHub pages部署hexo博客</h2><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>​    首先第一步，我们需要登录GitHub创建一个仓库，来作为我们博客文章及其他文件的存储地址. 在我们更新或者获取博客时，只需要对这个仓库进行commit等git操作即可完成更新、获取等操作.</p><p><strong>注意</strong></p><p>​    新建仓库的仓库名需要格外注意，我们新建仓库名字必须满足：</p><blockquote><p>“GitHub昵称”.github.io</p></blockquote><p>​    比如 我的GitHub昵称是<code>MagicStarLIN</code>，那么我的仓库名就应该如图所示：</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20200523183841443.png" alt="image-20200523183841443" style="zoom:50%;" /></p><p>仓库地址：<a href="https://github.com/MagicStarLIN/MagicStarLIN.github.io.git" target="_blank" rel="noopener">https://github.com/MagicStarLIN/MagicStarLIN.github.io.git</a></p><h3 id="安装git插件"><a href="#安装git插件" class="headerlink" title="安装git插件"></a>安装git插件</h3><p>​    仓库新建完成之后，我们回到我们的hexo目录文件夹下，我们需要安装一个git deploy的插件，这里借助cnpm来完成安装，只需要一个命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><h3 id="设置-config-yml"><a href="#设置-config-yml" class="headerlink" title="设置_config.yml"></a>设置_config.yml</h3><p>插件完成安装之后，我们需要对yml配置文件进行配置.</p><p>配置主要会在_config.yml文件中的deploy一级属性下进行配置.这里我的github仓库地址为<code>https://github.com/MagicStarLIN/MagicStarLIN.github.io.git</code></p><p>初始的_config.yml文件的deploy属性为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><p>基本处于什么都没有配置的状态，这里我直接展示我配置之后的yml文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/MagicStarLIN/MagicStarLIN.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h3 id="部署到远端"><a href="#部署到远端" class="headerlink" title="部署到远端"></a>部署到远端</h3><p>使用hexo的命令实现部署至GitHub pages</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>如果之前没有配置过git账号和密码，那么这里第一次部署应该会要求输入GitHub的账号和密码.</p><p>至此，成功之后，就已经完成了博客的部署.我们可以访问<code>&quot;GitHub昵称&quot;.github.io</code>url来直接访问自己的hexo博客.</p><h2 id="二、配置博客图床"><a href="#二、配置博客图床" class="headerlink" title="二、配置博客图床"></a>二、配置博客图床</h2><p>​    我们在写博客的时候，经常需要插入一些图片(比如上面的GitHub仓库截图)，这个时候因为markdown语法的图片插入是基于url的链接访问的. 比如我使用的是<strong>Typora编辑器</strong>来写markdown文档，那么他的图片会自动存储到电脑的某个固定文件夹中，我们在本地查看的markdown文档中的图片，就是访问的电脑中保存的图片. 那么当我们部署到GitHub上的时候就不能查看到博文中的图片了，这里我们就需要借助搭建好的<strong>图床</strong>来进行图片的访问.</p><blockquote><p>图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。</p></blockquote><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li>markdown文档编辑器：Typora</li><li>图床：阿里云对象存储OSS</li><li>图片上传工具：PicGo</li></ul><h3 id="图床搭建"><a href="#图床搭建" class="headerlink" title="图床搭建"></a>图床搭建</h3><p>首先购买阿里云的OSS服务.</p><p>访问<a href="https://www.aliyun.com/product/oss/" target="_blank" rel="noopener">阿里云对象存储OSS官网</a>，选择折扣套餐.</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20200523213310883.png" alt="image-20200523213310883" style="zoom:50%;" /></p><p>我购买的服务如图，大概一年9元.</p><p>之后进入管理控制台，在Bucket管理中选择创建Bucket.</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20200523213700289.png" alt="image-20200523213700289" style="zoom:50%;" /></p><p>这里我选择的Bucket具体细节如图，填写好Bucket名称之后，即可完成创建.</p><h3 id="PicGo配置"><a href="#PicGo配置" class="headerlink" title="PicGo配置"></a>PicGo配置</h3><p>下载PicGo，官方网站：<a href="https://molunerfinn.com/PicGo/" target="_blank" rel="noopener">https://molunerfinn.com/PicGo/</a>. 在官方网站选择下载，之后选择对应版本：</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20200523214053775.png" alt="image-20200523214053775" style="zoom:50%;" /></p><p>这里mac系统直接下载.dmg文件即可</p><p>下载完成后，我们需要对其进行配置，链接至我们的阿里云OSS</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/截屏2020-05-23 下午9.46.58.png" alt="截屏2020-05-23 下午9.46.58" style="zoom:50%;" /></p><ul><li><p>KeyId/KeySecret：阿里云OSS管理控制台 —&gt; Access Key —&gt; 使用Accesskey</p></li><li><p>存储空间名：即你刚刚创建的Bucket名称</p></li><li><p>存储区域：查看你的Bucket详细信息：</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20200523215241237_副本.png" alt="image-20200523215241237_副本" style="zoom:50%;" /></p></li><li><p>存储路径：在你的Bucket管理界面下，选择文件管理：</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20200523215521983.png" alt="image-20200523215521983" style="zoom:50%;" /></p><p>将文件名保存为存储路径，注意需要用“/”做结尾</p></li></ul><p>至此，PicGo配置完成.</p><h3 id="Typora配置"><a href="#Typora配置" class="headerlink" title="Typora配置"></a>Typora配置</h3><p>打开Typora偏好设置：</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20200523225811663.png" alt="image-20200523225811663" style="zoom:50%;" /></p><p>配置如图.</p><p>完成以上配置后，我么在使用Typora编写文档时，只需要对图片进行右键—&gt;上传图像即可. </p>]]></content>
      
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo搭建个人博客</title>
      <link href="/2020/05/21/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/05/21/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>通过快速简洁的博客框架<code>hexo</code>搭建个人博客，并将其托管至GitHub page平台</p></blockquote><h2 id="一、hexo简介"><a href="#一、hexo简介" class="headerlink" title="一、hexo简介"></a>一、hexo简介</h2><p>​    Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架.因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看.</p><p>​    官网：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo中文官网</a></p><p>​    </p><h2 id="二、环境"><a href="#二、环境" class="headerlink" title="二、环境"></a>二、环境</h2><p>操作系统：MacOS Catalina 10.15.4</p><p>Git版本：git version 2.24.3 (Apple Git-128)</p><p>Node.js版本：v12.16.2</p><h2 id="三、环境配置"><a href="#三、环境配置" class="headerlink" title="三、环境配置"></a>三、环境配置</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><blockquote><p>Node.js是一个基于Chrome V8 引擎的JavaScript运行时环境.</p></blockquote><p>下载地址：<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js中文官网</a></p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20200521230154161.png" alt="image-20200521230154161" style="zoom:50%;" /></p><p>我们选择LTS长期支持版（截图时已经更新至12.16.3） </p><p>Node.js安装完成包括两个部分</p><ul><li>Node.js本身</li><li>npm包管理器</li></ul><p><strong>下载安装</strong></p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20200521235944069.png" alt="image-20200521235944069" style="zoom:50%;" /></p><p>一直下一步即可完成安装</p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>因为MacOS系统初始就集成Git，所以不需要额外进行安装.所以我们首先验证当前系统是否已经安装Git环境.</p><p><strong>打开终端命令行工具</strong></p><p>输入命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git</span><br></pre></td></tr></table></figure><p>如若出现以下，则表示Git环境已经有效.</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20200522231946410.png" alt="image-20200522231946410" style="zoom:50%;" /></p><p>如果当前系统中不具备Git环境，可以通过<code>Homebrew</code>包管理工具进行Git的安装和配置.</p><p><a href="https://brew.sh" target="_blank" rel="noopener">Homebrew官方网站</a></p><h3 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h3><p>因为我们在搭建Hexo博客时，需要使用npm包管理工具进行hexo组件的下载安装，但是在国内npm下载速度并不理想，这里通过npm安装cnpm，cnpm是淘宝的镜像源，下载包的速度会更快一点.</p><p><strong>打开终端命令行工具</strong></p><p>输入命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=http:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure><p>指令执行完成，验证是否安装成功.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm</span><br></pre></td></tr></table></figure><p>出现以下，表示cnpm安装成功</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20200522232905099.png" alt="image-20200522232905099" style="zoom:50%;" /></p><h2 id="四、Hexo配置"><a href="#四、Hexo配置" class="headerlink" title="四、Hexo配置"></a>四、Hexo配置</h2><p>使用cnpm，安装hexo.</p><p><strong>打开终端命令行工具</strong></p><p>输入命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>等待安装完成</p><p>验证安装完成，输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v</span><br></pre></td></tr></table></figure><p>出现以下，证明安装完成</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20200523005709944.png" alt="image-20200523005709944" style="zoom:50%;" /></p><p>可以在上图中了解到hexo基于node</p><h2 id="五、使用hexo搭建博客"><a href="#五、使用hexo搭建博客" class="headerlink" title="五、使用hexo搭建博客"></a>五、使用hexo搭建博客</h2><p>选择合适的路径，创建博客文件夹，我这里创建了一个文件夹hexoBlog，所以我接下来的操作基本都是在这个文件夹下完成的.</p><blockquote><p>/Users/liuchanglin/Magic/hexoBlog</p></blockquote><p>所以，在接下来的搭建过程中，如果出现错误，可以随时删除这个文件夹重新来过.</p><p><strong>进入<code>/Users/liuchanglin/Magic/hexoBlog</code>目录</strong></p><p>搭建博客的命令只需要一个，非常简单.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>等待安装配置完成(这一步通常耗时比较长).</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20200523011010970.png" alt="image-20200523011010970" style="zoom:50%;" /></p><p>可以看到当前文件夹下已经生成了很多文件.</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20200523025022016.png" alt="image-20200523025022016" style="zoom:50%;" /></p><p>这些都是hexo生成的博客的基本的内容.</p><p>这个时候输入指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>可以看到出现以下信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http:<span class="comment">//localhost:4000 . Press Ctrl+C to stop.</span></span><br></pre></td></tr></table></figure><p>按住command键，点击链接，即可访问在本地启动的博客. 按ctrl+c键结束进程.</p><p>这个本地启动一般作为预览来使用.</p><p><img src="https://magic-picgo.oss-cn-beijing.aliyuncs.com/hexoBlog/image-20200523025422530.png" alt="image-20200523025422530" style="zoom:50%;" /></p><p>此时已经为你建立了一个<strong><em>hello word</em></strong>的博文，里面的内容也是hexo的基本操作.</p><p>至此，hexo搭建博客已经初步完成.</p><h2 id="六、hexo的基本操作"><a href="#六、hexo的基本操作" class="headerlink" title="六、hexo的基本操作"></a>六、hexo的基本操作</h2><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><p>新建文章使用命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n <span class="string">"博客title"</span></span><br></pre></td></tr></table></figure><p>执行完这个命令之后，就会在当前博客文件夹下的source/_posts文件夹中出现一个.md的文件，这就是博客文章文件了，因为hexo是可以使用markdown语法进行博客的撰写，也是十分方便.</p><h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><p>清理hexo产生的缓存文件、静态文件.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>在hexo文件夹下生成public文件夹</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>hexo支持更换主题，可以在hexo官网的主题分类下选择主题进行配置.</p><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题网站</a></p><p>在主题网站上选取主题之后，访问其github仓库，使用git将其pull到hexo博客文件夹中的theme文件夹中.</p><p>进入 themes 文件夹，使用命令.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone <span class="string">"项目地址"</span></span><br></pre></td></tr></table></figure><p>执行完成后，新增一个名称为主题名称的文件夹.</p><p><strong>配置_config.yml</strong></p><p>打开_config.yml，可以使用vim编辑器或者vs code等其他工具打开.</p><p>我这里选择使用vs code</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><p>yml末尾的theme属性，将landscape（初始主题）修改为themes文件夹中新的主题文件夹名称，保存.</p><p><strong>清理</strong>、<strong>构建</strong></p><p>即可完成主题的修改.</p>]]></content>
      
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown Grammar tutorial</title>
      <link href="/2020/04/26/markdown-Grammar-tutorial/"/>
      <url>/2020/04/26/markdown-Grammar-tutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown常用基础语法"><a href="#Markdown常用基础语法" class="headerlink" title="Markdown常用基础语法"></a>Markdown常用基础语法</h1><p>先想想我们一般写作时候需要用到什么样的排版？</p><p>无非就是标题、引用、强调（加粗、斜体、下划线）、插入链接、插入图片、列表（有序和无序列表），甚至连表格都很少用。</p><p><strong>标题语法</strong></p><p>Markdown一共支持6个级别大小的标题（对应于HTML语法里的h1~h6），写法很简单，就是在文字前空一格加上#号就行，几个#号就是几级标题，大小由大到小。</p><p># 第一级标题 <code>&lt;h1&gt;</code> </p><p>## 第二级标题 <code>&lt;h2&gt;</code> </p><p>###### 第六级标题 <code>&lt;h6&gt;</code></p><p>效果如下：</p><h1 id="第一级标题"><a href="#第一级标题" class="headerlink" title="第一级标题"></a>第一级标题</h1><h2 id="第二级标题"><a href="#第二级标题" class="headerlink" title="第二级标题"></a>第二级标题</h2><h6 id="第六级标题"><a href="#第六级标题" class="headerlink" title="第六级标题"></a>第六级标题</h6><p><strong>引用语法</strong></p><p>如果你想引用一段文字，那就使用大于号&gt;</p><blockquote><p>这是一段引用</p><p>这是另一段引用</p></blockquote><p>效果如下：</p><blockquote><p>这是一段引用</p><p>这是另一段引用</p></blockquote><p><strong>强调语法</strong></p><p><strong>粗体</strong></p><p>如果你想加粗一段文字，只需要在文字前后加两个*号</p><p><strong> 我很重要！</strong></p><p>效果如下：</p><p><strong>我很重要哦！</strong></p><p><strong>斜体 </strong></p><p>如果你想让一段文字倾斜，只需要在文字前后加一个星号*</p><p><em>我是比萨斜塔 </em></p><p>效果如下：</p><p><em>我是比萨斜塔</em></p><p><strong>下划线</strong></p><p>如果你想让一段文字加上下划线，只需要在文字前后加一个下划线_</p><p>_ 人是社会性动物_</p><p>效果如下：</p><p>_人是社会性动物_</p><p><strong>删除线</strong></p><p>如果你想让一段文字加上删除线效果，只需要在文字前后加一个波浪线~</p><p>~~ 我所说的都是错的~~</p><p>效果如下：</p><p><del>我所说的都是错的</del></p><p><strong>插入链接</strong></p><p>如果你想把一段文字加上链接指向到某个网址，就把文字用中括号围起来[]，然后加上一个小括号()，括号里填上网址即可。</p><p>[向阳乔木的博客] (<a href="http://tuijiankan.com" target="_blank" rel="noopener">http://tuijiankan.com</a>)</p><p>效果如下：</p><p><a href="https://link.zhihu.com/?target=http%3A//tuijiankan.com">向阳乔木的博客</a></p><p><strong>插入图片</strong></p><p>插入图片的语法和插入链接很像，就是在前面加了一个叹号!，注意：叹号是英文叹号。</p><p>![百度搜索] (<a href="https://www.baidu.com/img/bd_logo1.png" target="_blank" rel="noopener">https://www.baidu.com/img/bd_logo1.png</a>)</p><p>效果如下：</p><p><img src="data:image/png;base64,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" alt="img"></p><p><strong>列表</strong></p><p>列表分为有序列表和无序列表，什么是有序列表呢？就是1、2、3顺序排开。</p><p><strong>有序列表</strong></p><p>语法如下，注意：数字后加点. 再空一格写内容。</p><p>\1. 把冰箱门打开</p><p>\2. 把大象放进去</p><p>\3. 关上冰箱门</p><p>效果如下：</p><ol><li>把冰箱门打开</li><li>把大象放进去</li><li>关上冰箱门</li></ol><p><strong>无序列表</strong></p><p>无序列表只需要在文字前面加上减号-就行。（星号*或加号+也可以，看个人喜好，我比较喜欢用减号）</p><p>- 把冰箱门打开</p><p>- 把大象放进去</p><p>- 关上冰箱门</p><p>效果如下：</p><ul><li>把冰箱门打开</li><li>把大象放进去</li><li>关上冰箱门</li></ul><p><strong>其他标记</strong></p><p><strong>换行</strong></p><p>当你写大段文本分段的时候，只是回车换行是不行的，有些解释器出来的效果会让文字连在一起。</p><p>段落与段落之间需要强制空一行才能分段。</p><p><strong>分割线</strong></p><p>你可以在一行中使用三个以上的星号*或减号-来创建分割线（注意：行内不能有其他东西）</p><p>-—</p><hr><p>效果如下：</p><hr><hr><p><strong>Markdown高级语法</strong></p><p>还有一些不太常用的语法，比如插入代码区块、插入表格等等。</p><p><strong>代码区块</strong></p><p>如果你是一个程序员，需要分享自己的代码，那就需要创建代码区块，如果像普通的段落一样显示，格式可能会很糟糕。</p><p>当然，把整块文本放区块里也很常见，比如本文的语法解释部分。</p><p>语法：需要整体内容缩进 4 个空格或是 1 个制表符（tab）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'bluebird'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = <span class="built_in">Promise</span>.promisify(<span class="built_in">require</span>(<span class="string">'request'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">require</span>(<span class="string">"underscore.string"</span>);</span><br></pre></td></tr></table></figure><p>或者使用另外一种写法，就是在代码前后位置加上三个反引号`（数字键盘1左边那个按键）</p><p>如果是行内代码引用的话，只需要在代码前后加上一个反引号`。</p><p>Use the <code>whoisyourdaddy()</code> function.</p><p>效果如下：</p><p>Use the <code>whoisyourdaddy()</code> function.</p><p><strong>插入表格</strong></p><p>Markdown插入表格的语法相对复杂，必须要按格式来敲，注意表头与内容的分割线横线-不能少于3个。</p><p>第一格表头 | 第二格表头</p><p>—- | —-</p><p>内容单元格 第一列第一格 | 内容单元格第二列第一格</p><p>内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格</p><p>效果如下：</p>]]></content>
      
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/26/hello-world/"/>
      <url>/2020/04/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
